\documentclass[bachelor, och, diploma, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{{../diagrams/}{diagrams/}}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{minted}
\usepackage{array}
\usepackage{listings}
\usepackage{times}
\usepackage[colorlinks=true]{hyperref}
\usepackage[english,russian]{babel}

\usepackage{enumitem}


\lstset{
    backgroundcolor=\color{white},
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    frame=single,
    language=Go,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\No}{\textnumero}
\newtheorem{lem}{Лемма}
\setminted{style=bw,
	linenos=true,
	breaklines=true,
	numbersep=5pt,
	tabsize=2,
	fontsize=\small,
	bgcolor=white}
\setmintedinline{style=bw,
	bgcolor=white,
	fontsize=\normalsize
	}	

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Веб-приложение для саморазвития с интеллектуальной системой адаптации}

% Курс
\course{4}

% Группа
\group{451}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Стеклянникова Петра Сергеевича}

% Заведующий кафедрой
\chtitle{доцент, к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{Сафрончик М.И.}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{доцент, к.\,ф.-м.\,н.} 
\paname{Сафрончик М.И.}

% Семестр (только для практики, для остальных
% типов работ не используется)
% \term{7}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
% \practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{14}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.09.2025}
\practFinish{08.12.2025}

% Год выполнения отчета
\date{2026}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intro
Современное развитие цифровых технологий открывает новые возможности для создания адаптивных систем саморазвития и постановки целей. Такие системы призваны помочь пользователям эффективно планировать свой личностный рост, ставить достижимые цели и отслеживать прогресс в различных сферах жизни через геймифицированный подход.

Разрабатываемое веб-приложение представляет собой комплексную платформу для саморазвития, которая объединяет элементы геймификации, интеллектуальной персонализации и социального взаимодействия. Ключевой особенностью системы является ее адаптивность — способность подстраиваться под индивидуальные потребности и предпочтения каждого пользователя. Адаптивность достигается за счет двух взаимодополняющих механизмов: интеллектуальной системы рекомендаций на основе машинного обучения и автоматической генерации персонализированного контента через интеграцию с языковыми моделями.

Система рекомендаций использует современные алгоритмы машинного обучения (BERT) для анализа семантики контента и интересов пользователей, обеспечивая персонализированный подбор квестов и друзей с похожими целями. Генерация квестов через LLM API позволяет создавать уникальные задачи на основе текстовых запросов пользователей, адаптируя контент под их текущие потребности и интересы. Совместно эти механизмы обеспечивают динамическую адаптацию системы к каждому пользователю, создавая персонализированный опыт саморазвития.

Современные тенденции в разработке ПО, включая микросервисную архитектуру \cite{arch1}, прогресс в области машинного обучения и развитие облачных технологий, создают технологическую основу для реализации таких адаптивных систем. Микросервисный подход позволяет независимо масштабировать компоненты системы, а интеграция ML-сервисов обеспечивает интеллектуальную обработку данных для персонализации.

Практика посвящена исследованию, проектированию и разработке полнофункционального веб-приложения для саморазвития и постановки целей с интеллектуальной системой адаптации. В работе рассматриваются архитектурные решения для интеграции ML-сервисов, сравнивается эффективность различных алгоритмов рекомендаций, анализируются реализация системы генерации персонализированного контента.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textbf{Целью практики} является исследование, проектирование и разработка адаптивного веб-приложения для саморазвития и постановки целей с интеллектуальной системой персонализации, представляющей собой полнофункциональную платформу с микросервисной архитектурой, интегрирующей современные алгоритмы машинного обучения (BERT) для рекомендаций и языковые модели для генерации персонализированного контента.

Для достижения поставленной цели в работе решается комплекс взаимосвязанных задач:

\begin{enumerate}
    \item Проведение комплексного анализа предметной области, включая изучение современных подходов к адаптивным системам саморазвития, алгоритмов персонализации (Collaborative Filtering, Content-Based Filtering, BERT) и методов генерации контента через языковые модели.
    
    \item Исследование и сравнительный анализ алгоритмов машинного обучения для персонализации: Collaborative Filtering на основе KNN, TF-IDF для текстового поиска, BERT для семантического анализа. Проведение сравнительного тестирования для выявления наиболее эффективного алгоритма.
    
    \item Формирование и обоснование требований к разрабатываемой системе, включая функциональные требования (управление квестами и задачами, система рекомендаций, AI-генерация контента, социальные взаимодействия) и нефункциональные требования (производительность, точность рекомендаций, масштабируемость).
    
    \item Проведение сравнительного анализа технологий и инструментов разработки для обоснованного выбора технологического стека, включающего средства реализации основного backend (Go, Gin), ML-сервиса (Python, FastAPI), интеграции с LLM API и системы хранения данных.
    
    \item Проектирование архитектуры адаптивной системы на основе микросервисного подхода с определением границ сервисов, схем взаимодействия между основным backend (Go), Recommendation Service (Python) и внешними сервисами (LLM API), моделей данных и API-интерфейсов.
       
    \item Реализация алгоритма семантического поиска на основе BERT для поиска квестов с учетом семантического сходства текстовых описаний, преодолевающего ограничения ключевых слов.
    
    \item Реализация алгоритма рекомендации квестов на основе BERT, использующего семантический анализ приобретенных квестов пользователя для генерации персонализированных рекомендаций.
    
    \item Реализация алгоритма рекомендации друзей на основе BERT, анализирующего семантическое сходство интересов пользователей через BERT-эмбеддинги приобретенных квестов.
    
    \item Разработка Recommendation Service на Python с использованием FastAPI, обеспечивающего RESTful API для взаимодействия с основным backend и эффективную обработку запросов на рекомендации.
    
    \item Интеграция Recommendation Service с основным backend-приложением (Go), включая реализацию клиентских компонентов для взаимодействия с ML-сервисом, обработку ошибок и таймаутов.
    
    \item Проведение сравнительного анализа эффективности различных алгоритмов (BERT vs TF-IDF vs Collaborative Filtering) на реальных данных, оценка метрик качества рекомендаций (precision, recall, F1-score).
    
    \item Обеспечение производительности и масштабируемости Recommendation Service через оптимизацию алгоритмов, кэширование результатов и эффективную работу с данными.
    
    \item Документирование процесса проектирования, разработки и развертывания системы рекомендаций, включая описание алгоритмов, архитектурных решений, API-документацию и результаты сравнительного анализа.
\end{enumerate}

Решение указанных задач позволит создать полнофункциональный, технологически современный и практически значимый программный продукт, демонстрирующий комплексный подход к решению проблемы персонализации контента и рекомендаций на основе машинного обучения, а также подтверждающий высокий уровень профессиональной подготовки автора работы в области программной инженерии и машинного обучения.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Анализ предметной области и существующих решений}

\subsection{Актуальность темы разработки адаптивных систем саморазвития}

Разработка адаптивных систем для саморазвития и постановки целей представляет собой актуальное направление на стыке программной инженерии, машинного обучения и психологии мотивации. Актуальность темы обусловлена растущим интересом к цифровым инструментам для личностного роста и необходимостью создания систем, способных адаптироваться под индивидуальные потребности каждого пользователя.

Во-первых, наблюдается устойчивый рост спроса на цифровые платформы для саморазвития, которые помогают пользователям ставить цели, отслеживать прогресс и получать персонализированные рекомендации. Геймификация и системы мотивации показывают высокую эффективность в повышении вовлеченности пользователей и достижении целей. Персонализированные системы демонстрируют значительное преимущество по сравнению с универсальными решениями за счет адаптации под индивидуальные потребности каждого пользователя.

Во-вторых, адаптивность таких систем достигается за счет интеллектуальной персонализации контента. Современные алгоритмы машинного обучения, такие как BERT, позволяют анализировать семантику контента и интересы пользователей для генерации персонализированных рекомендаций. Дополнительно, интеграция с языковыми моделями (LLM) открывает возможности для автоматической генерации уникального контента, адаптированного под текущие потребности пользователя. Совместное использование этих механизмов создает динамически адаптирующуюся систему, которая подстраивается под каждого пользователя.

С технологической точки зрения актуальность темы подчеркивается созреванием необходимых технологических предпосылок: широкое распространение облачных вычислений, развитие микросервисных архитектур \cite{arch1}, прогресс в области обработки естественного языка и доступность предобученных моделей создают уникальную возможность для построения действительно интеллектуальных адаптивных систем.


\subsection{Анализ современной литературы и существующих решений}
\subsubsection{Алгоритмы Collaborative Filtering}

Collaborative Filtering является одним из наиболее распространенных подходов к построению систем рекомендаций. Основная идея метода заключается в использовании поведения и предпочтений других пользователей для предсказания интересов целевого пользователя. В работе Sarwar et al. (2001) \cite{collaborative_filtering_sarwar} «Item-based collaborative filtering recommendation algorithms» подробно рассматриваются различные варианты Collaborative Filtering, включая user-based (поиск похожих пользователей) и item-based (поиск похожих элементов) подходы.

K-ближайших соседей (KNN) является классическим алгоритмом Collaborative Filtering, который находит пользователей или элементы, наиболее похожие на целевой объект, на основе метрик сходства (косинусное сходство, корреляция Пирсона — мера линейной зависимости между двумя переменными). Преимуществами KNN являются простота реализации и интерпретируемость результатов. Однако метод страдает от проблемы разреженности данных (sparsity problem) и холодного старта (cold start problem) для новых пользователей или элементов.

В работе Ricci et al. (2011) \cite{recommender_handbook} «Recommender Systems Handbook» систематизированы различные подходы к Collaborative Filtering, включая матричную факторизацию и глубокое обучение.

\subsubsection{Методы текстового поиска: TF-IDF}

Term Frequency-Inverse Document Frequency (TF-IDF) \cite{tfidf_original, tfidf_modern} является классическим методом для оценки важности терминов в документах относительно коллекции документов. Формула TF-IDF определяется как:

$$TF\text{-}IDF(t,d) = TF(t,d) \times IDF(t)$$

где $TF(t,d)$ — частота термина $t$ в документе $d$, а $IDF(t) = \log\frac{N}{df(t)}$ — обратная частота документа, где $N$ — общее количество документов, а $df(t)$ — количество документов, содержащих термин $t$.

TF-IDF широко используется для текстового поиска и ранжирования документов. В контексте систем рекомендаций TF-IDF позволяет находить элементы с похожим текстовым содержанием, что особенно полезно для рекомендации контента на основе описаний. Однако метод имеет ограничения: он не учитывает семантическое сходство и синонимию, работает только с точными совпадениями терминов.

\subsubsection{Семантический анализ на основе BERT}

Bidirectional Encoder Representations from Transformers (BERT) представляет собой модель трансформера \cite{transformer_attention}, предобученную на больших корпусах текстов. BERT способен понимать контекст слов в обоих направлениях (bidirectional), что позволяет ему лучше улавливать семантические связи по сравнению с традиционными методами.

В работе Devlin et al. (2018) \cite{bert_original} «BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding» показано, что BERT достигает state-of-the-art (наилучших на момент публикации) результатов в различных задачах обработки естественного языка. Для задач семантического поиска BERT \cite{bert_semantic_search} позволяет находить документы, семантически похожие на запрос, даже при отсутствии точных совпадений терминов.

Применение BERT для рекомендаций требует вычисления эмбеддингов текстовых описаний и использования метрик сходства (например, косинусное сходство) для поиска похожих элементов. Преимуществами BERT являются способность понимать семантику и контекст, что преодолевает ограничения TF-IDF. Однако метод требует значительных вычислительных ресурсов и времени на инференс (процесс применения обученной модели для получения предсказаний на новых данных).

\subsubsection{Выбор алгоритма для продакшена}

В рамках данной работы был проведен сравнительный анализ различных подходов к рекомендациям. Хотя теоретически гибридные методы могут показывать лучшие результаты, для данной системы было принято решение использовать только BERT. Это обусловлено несколькими практическими соображениями: во-первых, BERT демонстрирует достаточную точность для решения задач системы, во-вторых, использование единого алгоритма упрощает архитектуру и поддержку системы, в-третьих, это снижает вычислительную нагрузку по сравнению с комбинированием нескольких алгоритмов. Кроме того, BERT способен одновременно учитывать семантику контента и выявлять паттерны в данных пользователей через семантические профили, что делает его универсальным решением для всех задач системы (поиск квестов, рекомендация квестов, рекомендация друзей). Также стоит отметить, что при тестировании гибридного подхода (комбинация BERT и Collaborative Filtering) результаты были немного лучше, но разница не оправдывала усложнение архитектуры системы.

\subsubsection{Технологические аспекты разработки ML-сервисов}

Современная литература по программной инженерии предлагает различные архитектурные подходы к построению систем машинного обучения. Работа Ричардсона (Richardson, 2018) \cite{microservices_richardson} «Microservices Patterns» обосновывает преимущества микросервисной архитектуры для систем, требующих высокой масштабируемости и возможности независимого развертывания компонентов. Для ML-сервисов, которые могут требовать различных вычислительных ресурсов и частых обновлений моделей, такой подход представляется особенно подходящим \cite{microservices_martin}.

FastAPI \cite{fastapi_docs}, современный веб-фреймворк для Python \cite{python_docs}, обеспечивает высокую производительность и простоту разработки RESTful API для ML-сервисов. В работе Ramírez (2021) \cite{fastapi_ramirez} «FastAPI Modern Python Web Development» рассматриваются практики разработки ML-сервисов с использованием FastAPI, включая асинхронную обработку запросов, валидацию данных и документацию API.

Вопросы производительности и масштабируемости ML-сервисов подробно освещены в работе Huyen (2022) \cite{ml_systems_huyen} «Designing Machine Learning Systems», где рассматриваются методы оптимизации инференса, кэширования результатов и батчинга запросов (группировка нескольких запросов для одновременной обработки) для повышения пропускной способности системы.

\subsubsection{Анализ существующих систем рекомендаций}

Современные коммерческие системы рекомендаций (Amazon \cite{amazon_recommender}, Netflix \cite{netflix_recommender}, Spotify, YouTube) используют комбинации различных алгоритмов, включая Collaborative Filtering, матричную факторизацию и глубокое обучение. Однако детали реализации таких систем являются проприетарными и не раскрываются, что затрудняет воспроизведение результатов и сравнительный анализ эффективности различных подходов. Открытые реализации, демонстрирующие сравнительный анализ эффективности различных методов (BERT, TF-IDF, Collaborative Filtering) в единой системе, встречаются редко, что определяет актуальность разработки системы с открытой реализацией и сравнительным анализом алгоритмов.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Технологические аспекты разработки систем рекомендаций}
\subsubsection{Архитектурные подходы и микросервисная архитектура}

В контексте разработки систем рекомендаций особое значение приобретает выбор архитектурного подхода, обеспечивающего разделение основного backend и ML-сервиса. Микросервисная архитектура позволяет независимо разрабатывать, развертывать и масштабировать компоненты системы, что критически важно для ML-сервисов, требующих различных вычислительных ресурсов и частых обновлений моделей. Детальное описание выбранного технологического стека и обоснование выбора представлено в разделе "Технологический стек и обоснование выбора".

\subsubsection{Библиотеки машинного обучения и обработки естественного языка}

Для реализации алгоритмов рекомендаций используются следующие библиотеки Python:

\textbf{sentence-transformers} \cite{sentence_transformers} — библиотека для работы с предобученными моделями трансформеров, включая BERT. Позволяет легко получать семантические эмбеддинги текстов для вычисления сходства между описаниями квестов. Используется многоязычная модель \texttt{paraphrase-multilingual-MiniLM-L12-v2}, оптимизированная для задач семантического поиска и поддерживающая работу с текстами на различных языках.

\textbf{scikit-learn} — библиотека для машинного обучения, используемая для реализации Collaborative Filtering на основе KNN. Предоставляет эффективные реализации алгоритмов ближайших соседей с различными метриками расстояния (косинусное сходство, евклидово расстояние).

\textbf{TfidfVectorizer} из scikit-learn — используется для реализации TF-IDF поиска. Обеспечивает векторизацию текстов с учетом частоты терминов и обратной частоты документов, что позволяет эффективно находить релевантные квесты по текстовым запросам.

\textbf{numpy и scipy} — используются для эффективных вычислений с матрицами и векторами, необходимых для вычисления метрик сходства и обработки эмбеддингов.

\subsubsection{Взаимодействие между микросервисами}

Взаимодействие между основным backend (Go) и Recommendation Service (Python) осуществляется через RESTful API. Основной backend отправляет HTTP POST запросы к Recommendation Service с таймаутом 30 секунд для предотвращения зависаний при обработке запросов.

Структура взаимодействия:
\begin{itemize}
    \item \texttt{POST /api/search} — поиск квестов по текстовому запросу (BERT)
    \item \texttt{POST /api/quests/recommend} — рекомендация квестов на основе истории пользователя (BERT)
    \item \texttt{POST /api/users/recommend} — рекомендация друзей на основе семантического сходства интересов (BERT)
    \item \texttt{POST /api/quests/add} — добавление новых квестов в индекс для поиска
    \item \texttt{POST /api/users/add} — добавление данных пользователей для Collaborative Filtering
\end{itemize}

Все запросы используют JSON для сериализации данных. Recommendation Service возвращает результаты с оценками сходства (similarity scores) и объяснениями рекомендаций, что позволяет пользователям понимать, почему им рекомендован тот или иной контент.

\subsubsection{Кэширование и оптимизация производительности}

Для обеспечения высокой производительности Recommendation Service используются техники кэширования эмбеддингов. Детальное описание реализованных оптимизаций представлено в разделе \ref{subsec:performance_optimization}.

\subsubsection{API design и REST principles}

RESTful API проектируется в соответствии с принципами \cite{api1}:
\begin{itemize}
    \item \textbf{Stateless взаимодействие} (без сохранения состояния) — каждый запрос содержит всю необходимую информацию для обработки, сервер не хранит состояние сессии между запросами.
    
    \item \textbf{Единообразие интерфейса} — использование стандартных HTTP методов (GET, POST) и единообразной структуры URL для всех ресурсов, что упрощает понимание и использование API.
    
    \item \textbf{Кэшируемость ответов} — ответы сервера могут быть кэшированы клиентом для уменьшения нагрузки.
    
    \item \textbf{Слоистая архитектура} — разделение на слои, где каждый слой имеет четко определенную ответственность, что обеспечивает модульность и тестируемость системы.
\end{itemize}

Пример структуры endpoint'ов:
\begin{verbatim}
POST   /user/register              - регистрация
POST   /user/login                 - аутентификация
GET    /user/profile               - получение профиля
GET    /quests/available            - получение доступных квестов
POST   /quests/:questID/purchase   - покупка квеста
POST   /quests/:questID/start      - старт квеста
POST   /quests/:questID/:taskID/complete - выполнение задачи
GET    /friends                    - список друзей
POST   /friends/by-name/:friend_name - добавление друга по имени
\end{verbatim}

\subsubsection{Мониторинг и логирование}

Для обеспечения наблюдаемости (observability) системы применяются:
\begin{itemize}
    \item Разные уровни логирования (DEBUG, INFO, WARN, ERROR)
    \item Health checks и readiness probes
\end{itemize}

\subsubsection{Тестирование и качество кода}

Эти технологические аспекты формируют прочный фундамент для создания надежной, масштабируемой и эффективной системы рекомендаций, способной обрабатывать большие объемы данных и обеспечивать высокую точность рекомендаций.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Проектирование и реализация системы}

\subsection{Архитектура системы}

Разрабатываемая система построена на микросервисной архитектуре с использованием технологического стека Go + Gin + PostgreSQL для основного backend, Python + FastAPI для Recommendation Service и HTML + CSS + JavaScript для frontend. Архитектура обеспечивает разделение ответственности между сервисами и возможность независимого масштабирования компонентов \cite{arch1}.
Общая архитектура системы представлена на рис. \ref{fig:architecture}.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.1\textwidth]{../diagrams/arch_diagram.png}
    \caption{Общая архитектура системы}
    \label{fig:architecture}
\end{figure}

Система организована в четыре основных слоя:
\begin{itemize}
    \item \textbf{Frontend Layer} - веб-приложение на HTML и JavaScript, отвечающее за пользовательский интерфейс
    \item \textbf{Backend Layer} - Go сервер с фреймворком Gin, реализующий бизнес-логику и REST API
    \item \textbf{ML Service Layer} - Python сервис на FastAPI, реализующий алгоритмы рекомендаций и поиска на основе BERT (TF-IDF и Collaborative Filtering были протестированы для сравнения, но не используются в продакшене)
    \item \textbf{Data Layer} - PostgreSQL база данных для хранения всей информации системы
\end{itemize}

Взаимодействие между Backend Layer и ML Service Layer осуществляется через HTTP REST API с таймаутами для обеспечения отказоустойчивости системы.  

\subsubsection{Технологический стек и обоснование выбора}

\textbf{Backend} реализован на Go с использованием фреймворка Gin \cite{go_backend}. Выбор Go обусловлен его отличной поддержкой конкурентности, что критически важно для системы, обрабатывающей множество одновременных запросов к Recommendation Service \cite{go_practice}.

\textbf{Recommendation Service} реализован на Python \cite{python_docs} с использованием FastAPI \cite{fastapi_docs, fastapi_ramirez}. Выбор Python обусловлен богатой экосистемой библиотек для машинного обучения (sentence-transformers \cite{sentence_transformers} для BERT) и простотой интеграции предобученных моделей. В процессе разработки также использовались scikit-learn для реализации TF-IDF и Collaborative Filtering для сравнительного тестирования, но в продакшене используется только BERT.

\textbf{База данных} — PostgreSQL выбрана как надежная реляционная СУБД с богатым функционалом, поддерживающая сложные запросы и транзакции \cite{db1}. Используется для хранения метаданных квестов, истории взаимодействия пользователей и данных для построения семантических профилей.

\textbf{База данных Recommendation Service} — SQLite \cite{sqlite_docs} используется для хранения BERT-эмбеддингов квестов и семантических профилей пользователей. Выбор SQLite обусловлен простотой развертывания (файловая база данных), достаточной производительностью для средних объемов данных и возможностью хранения бинарных данных (BLOB) для эмбеддингов. Данные сохраняются одновременно в SQLite для персистентности и в памяти для быстрого доступа, что обеспечивает высокую производительность при поиске и рекомендациях.

\textbf{Frontend} разработан на HTML \cite{html2} и JavaScript \cite{js2} без использования фреймворков. Выбор нативного подхода обусловлен простотой разработки и отсутствием зависимостей. Приложение использует современные библиотеки для специфических задач (FullCalendar для календаря, Cytoscape.js для визуализации графов квестов).

\subsection{Реализация алгоритмов рекомендаций и поиска}

В рамках разработки системы были протестированы различные алгоритмы машинного обучения для поиска и рекомендаций: TF-IDF, Collaborative Filtering (KNN) и BERT. Для оценки качества использовались метрики Precision@K, Recall@K, F1-score@K и NDCG@K. Сравнительный анализ на реальных данных показал превосходство BERT по всем метрикам качества, что в сочетании с его универсальностью (один алгоритм для всех задач) привело к выбору BERT как единственного алгоритма для продакшена.

\subsubsection{Метрики оценки качества}

Для оценки эффективности алгоритмов использовались следующие метрики:
\begin{itemize}
    \item \textbf{Precision@K} — доля релевантных элементов среди top-K рекомендаций
    \item \textbf{Recall@K} — доля найденных релевантных элементов от общего количества релевантных
    \item \textbf{F1-score@K} — гармоническое среднее precision и recall
    \item \textbf{NDCG@K} — нормализованный дисконтированный кумулятивный выигрыш, учитывающий позицию релевантных элементов в ранжированном списке
\end{itemize}

\subsubsection{Сравнительное тестирование: TF-IDF vs BERT}

В процессе разработки был реализован и протестирован алгоритм TF-IDF для сравнения с BERT. TF-IDF (Term Frequency-Inverse Document Frequency) работает следующим образом:

\begin{enumerate}
    \item \textbf{Векторизация квестов}: Каждый квест представляется в виде вектора TF-IDF на основе его названия, описания и категории. Используется \texttt{TfidfVectorizer} из scikit-learn с параметром максимального количества признаков: 1000.
    
    \item \textbf{Векторизация запроса}: Пользовательский запрос преобразуется в вектор TF-IDF с использованием той же модели векторизации.
    
    \item \textbf{Вычисление сходства}: Косинусное сходство между вектором запроса и векторами всех квестов вычисляется по формуле:
    $$\text{similarity}(q, d) = \frac{\mathbf{q} \cdot \mathbf{d}}{||\mathbf{q}|| \times ||\mathbf{d}||}$$
    где $\mathbf{q}$ — вектор запроса, $\mathbf{d}$ — вектор документа (квеста).
    
    \item \textbf{Ранжирование и фильтрация}: Квесты ранжируются по убыванию сходства, применяется фильтрация по категориям и статусу (если указано), возвращаются top-K наиболее релевантных результатов.
\end{enumerate}

Преимущества TF-IDF: быстрая обработка запросов (O(n) где n — количество квестов), низкие требования к вычислительным ресурсам, хорошая интерпретируемость результатов.

Ограничения: не учитывает семантическое сходство (синонимы, контекст), работает только с точными совпадениями терминов, требует предобработки текста (токенизация, стемминг).

\textbf{Результаты тестирования} (рекомендации квестов):
\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|c|}
        \hline
        \textbf{Алгоритм} & \textbf{Precision@5} & \textbf{Recall@5} & \textbf{F1@5} & \textbf{NDCG@5} \\
        \hline
        TF-IDF & 0.480 & 0.306 & 0.370 & 0.482 \\
        \hline
        Collaborative Filtering (KNN, k=3) & 0.400 & 0.246 & 0.303 & 0.464 \\
        \hline
        BERT & 0.540 & 0.338 & 0.412 & 0.569 \\
        \hline
    \end{tabular}
    \caption{Сравнение алгоритмов для рекомендации квестов}
    \label{tab:quest_recommendation}
\end{table}

BERT продемонстрировал более высокие результаты по всем метрикам по сравнению с TF-IDF и Collaborative Filtering. Хотя разница незначительна, BERT показал лучшее понимание семантики и контекста, что важно для работы с текстовыми описаниями квестов. В связи с этим для продакшена был выбран BERT.

\subsubsection{Алгоритм семантического поиска на основе BERT (основной метод)}

BERT (Bidirectional Encoder Representations from Transformers) \cite{bert_original, bert_semantic_search} используется для семантического поиска квестов, преодолевающего ограничения ключевых слов. Алгоритм реализован следующим образом:

\begin{enumerate}
    \item \textbf{Предобработка текстов}: Названия и описания квестов объединяются в единый текст, который нормализуется (удаление лишних пробелов, приведение к нижнему регистру).
    
    \item \textbf{Генерация эмбеддингов}: Используется предобученная многоязычная модель \texttt{paraphrase-multilingual-MiniLM-L12-v2} из библиотеки sentence-transformers \cite{sentence_transformers}. Модель генерирует 384-мерные эмбеддинги для каждого квеста и поддерживает работу с текстами на различных языках:
    $$\mathbf{e}_d = \text{BERT}(\text{concat}(\text{title}_d, \text{description}_d))$$
    где $\mathbf{e}_d$ — эмбеддинг квеста $d$.
    
    \item \textbf{Кэширование эмбеддингов}: Эмбеддинги всех квестов предвычисляются при загрузке сервиса и сохраняются в памяти для быстрого доступа, что позволяет избежать повторных вычислений при каждом запросе.
    
    \item \textbf{Семантический поиск}: При получении поискового запроса генерируется эмбеддинг запроса $\mathbf{e}_q$, затем вычисляется косинусное сходство со всеми эмбеддингами квестов:
    $$\text{similarity}(q, d) = \cos(\mathbf{e}_q, \mathbf{e}_d) = \frac{\mathbf{e}_q \cdot \mathbf{e}_d}{||\mathbf{e}_q|| \times ||\mathbf{e}_d||}$$
    
    \item \textbf{Ранжирование}: Квесты ранжируются по убыванию семантического сходства, возвращаются top-K наиболее релевантных результатов.
\end{enumerate}

Преимущества BERT: понимание семантики и контекста, способность находить релевантные результаты даже при отсутствии точных совпадений терминов, учет синонимов и связанных понятий, превосходство по всем метрикам качества по сравнению с TF-IDF.

Ограничения: более высокие требования к вычислительным ресурсам, большее время обработки запросов по сравнению с TF-IDF, необходимость предобученных моделей. Однако улучшение качества рекомендаций компенсирует увеличение времени обработки.

Результаты тестирования BERT для поиска квестов представлены в таблице \ref{tab:quest_recommendation}. На основе этих результатов BERT выбран как основной и единственный алгоритм для поиска квестов в продакшене.

\subsubsection{Сравнительное тестирование: Collaborative Filtering (KNN) vs BERT}

Также в процессе разработки был реализован и протестирован алгоритм Collaborative Filtering на основе KNN для сравнения с BERT. Collaborative Filtering работает следующим образом:

\begin{enumerate}
    \item \textbf{Построение матрицы взаимодействий}: Создается бинарная матрица $M_{n \times m}$, где $n$ — количество пользователей, $m$ — количество квестов. Элемент $M_{i,j}$ представляет наличие квеста у пользователя:
    $$M_{i,j} = \begin{cases}
        1 & \text{если пользователь } i \text{ добавил квест } j \text{ себе} \\
        0 & \text{иначе}
    \end{cases}$$
    
    \item \textbf{Вычисление сходства пользователей}: Для целевого пользователя $u$ вычисляется сходство со всеми другими пользователями с использованием косинусного сходства:
    $$\text{similarity}(u, v) = \frac{\mathbf{M}_u \cdot \mathbf{M}_v}{||\mathbf{M}_u|| \times ||\mathbf{M}_v||}$$
    где $\mathbf{M}_u$ и $\mathbf{M}_v$ — векторы взаимодействий пользователей $u$ и $v$.
    
    \item \textbf{Поиск K ближайших соседей}: Используется алгоритм KNN из scikit-learn (\texttt{NearestNeighbors}) с метрикой косинусного сходства для нахождения K наиболее похожих пользователей (по умолчанию K=3).
    
    \item \textbf{Генерация рекомендаций}: Для каждого квеста, который не был добавлен целевым пользователем, вычисляется сумма весов похожих пользователей, у которых есть этот квест:
    $$\text{score}(u, q) = \sum_{v \in N(u)} w(u, v) \times \mathbf{1}_{M_{v,q} = 1}$$
    где $N(u)$ — множество K ближайших соседей пользователя $u$, $w(u, v) = 1 - d(u, v)$ — вес на основе косинусного расстояния $d(u, v)$ между пользователями, $\mathbf{1}_{M_{v,q} = 1}$ — индикатор наличия квеста $q$ у пользователя $v$.
    
    \item \textbf{Ранжирование и фильтрация}: Квесты ранжируются по убыванию score, применяется фильтрация по категориям (если указано), возвращаются top-K наиболее релевантных рекомендаций.
\end{enumerate}

Преимущества Collaborative Filtering: учет поведенческих паттернов пользователей, способность находить неочевидные связи между квестами, не требует анализа содержания квестов.

Ограничения: проблема холодного старта для новых пользователей или квестов, проблема разреженности данных при малом количестве взаимодействий, вычислительная сложность O(n²) для больших пользовательских баз.

Результаты тестирования Collaborative Filtering представлены в таблице \ref{tab:quest_recommendation}. BERT превосходит Collaborative Filtering по всем метрикам. В связи с этим для продакшена выбран BERT как единственный алгоритм для рекомендаций.

\subsubsection{Использование BERT для рекомендаций квестов}

На основе результатов сравнительного тестирования для рекомендаций квестов и друзей используется семантический анализ на основе BERT. Алгоритм работает следующим образом:

\begin{enumerate}
    \item \textbf{Построение семантического профиля интересов пользователя}: На основе приобретенных квестов пользователя формируется семантический профиль через BERT-эмбеддинги приобретенных квестов. Профиль представляет собой усредненный эмбеддинг всех приобретенных квестов:
    $$\mathbf{p}_u = \frac{1}{|U|} \sum_{q \in U} \mathbf{e}_q$$
    где $U$ — множество приобретенных квестов пользователя $u$, $\mathbf{e}_q$ — BERT-эмбеддинг квеста $q$.
    
    \item \textbf{Семантическое ранжирование квестов}: Для каждого потенциально рекомендованного квеста вычисляется семантическое сходство с профилем пользователя:
    $$\text{score}(u, q) = \cos(\mathbf{p}_u, \mathbf{e}_q)$$
    где $\mathbf{e}_q$ — BERT-эмбеддинг квеста $q$.
    
    \item \textbf{Фильтрация и ранжирование}: Квесты фильтруются по категориям (если указано) и ранжируются по убыванию score, возвращаются top-K рекомендаций с объяснениями на основе семантического сходства.
\end{enumerate}

Преимущества использования BERT для рекомендаций: глубокое понимание семантики контента, способность находить релевантные квесты даже при отсутствии точных совпадений, учет контекста и связанных понятий, превосходство по всем метрикам качества по сравнению с Collaborative Filtering.

\subsubsection{Использование BERT для рекомендаций друзей}

Рекомендация друзей основана на семантическом анализе интересов пользователей с использованием BERT:

\begin{enumerate}
    \item \textbf{Построение семантического профиля интересов пользователя}: Для каждого пользователя создается семантический профиль на основе BERT-эмбеддингов приобретенных квестов. Профиль представляет собой усредненный эмбеддинг всех приобретенных квестов:
    $$\mathbf{p}_u = \frac{1}{|U|} \sum_{q \in U} \mathbf{e}_q$$
    где $U$ — множество приобретенных квестов пользователя $u$, $\mathbf{e}_q$ — BERT-эмбеддинг квеста $q$.
    
    \item \textbf{Вычисление семантического сходства интересов}: Для целевого пользователя вычисляется косинусное сходство его семантического профиля со всеми другими пользователями:
    $$\text{similarity}(u, v) = \cos(\mathbf{p}_u, \mathbf{p}_v)$$
    где $\mathbf{p}_u$ и $\mathbf{p}_v$ — семантические профили пользователей.
    
    \item \textbf{Ранжирование пользователей}: Пользователи ранжируются по убыванию семантического сходства.
    
    \item \textbf{Фильтрация существующих друзей}: Из списка рекомендаций исключаются пользователи, с которыми уже установлена дружба.
    
    \item \textbf{Генерация объяснений}: Для каждой рекомендации генерируется объяснение на основе семантического сходства интересов и общих категорий приобретенных квестов.
\end{enumerate}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|c|}
        \hline
        \textbf{Алгоритм} & \textbf{Precision@3} & \textbf{Recall@3} & \textbf{F1@3} \\
        \hline
        TF-IDF & 0.633 & 0.658 & 0.636 \\
        \hline
        Collaborative Filtering (KNN, k=3) & 0.633 & 0.650 & 0.631 \\
        \hline
        BERT & 0.633 & 0.700 & 0.641 \\
        \hline
    \end{tabular}
    \caption{Сравнение алгоритмов для рекомендации друзей}
    \label{tab:friend_recommendation}
\end{table}

Все три алгоритма показали схожие результаты по precision, но BERT продемонстрировал лучший recall (0.700), что означает способность находить больше релевантных друзей. Это важно для социальных функций системы. Кроме того, использование единого алгоритма (BERT) для всех задач системы (поиск квестов, рекомендация квестов, рекомендация друзей) упрощает архитектуру и поддержку.

Преимущества использования BERT для рекомендации друзей: глубокое понимание семантики интересов пользователей, способность находить друзей с похожими интересами даже при отсутствии точных совпадений в категориях, учет контекста и связанных понятий в выполненных квестах.

\subsubsection{Общие выводы по сравнительному анализу}

BERT демонстрирует лучшие результаты по всем метрикам по сравнению с TF-IDF и Collaborative Filtering. Особенно заметно преимущество по NDCG@5 для рекомендаций квестов (0.569 против 0.482 у TF-IDF и 0.464 у Collaborative Filtering), что говорит о лучшем ранжировании результатов. Хотя разница в F1-score незначительна, BERT лучше понимает семантику текстовых описаний квестов \cite{bert_vs_tfidf_cogito, bert_vs_tfidf_iieta}, что важно для качества рекомендаций. На основе этих результатов BERT был выбран как единственный алгоритм для всех задач системы в продакшене.

\subsection{Реализация основного backend-приложения}

Основной backend-сервис реализован на Go с использованием фреймворка Gin и обеспечивает всю бизнес-логику приложения, взаимодействие с базой данных PostgreSQL и интеграцию с внешними сервисами (LLM API и Recommendation Service).

\subsubsection{Система аутентификации и авторизации}

Реализована полнофункциональная система аутентификации на основе JWT (JSON Web Tokens). Процесс аутентификации включает следующие этапы:

\begin{enumerate}
    \item \textbf{Регистрация пользователя}: При регистрации пароль хешируется с использованием алгоритма bcrypt с параметром \texttt{bcrypt.DefaultCost} (равен 10), что обеспечивает защиту от brute-force атак. Хеш пароля сохраняется в таблице \texttt{users} вместе с уникальными \texttt{username} и \texttt{email}.
    
    \item \textbf{Аутентификация}: При успешной аутентификации генерируется JWT токен с временем жизни 24 часа. Токен содержит идентификатор пользователя (\texttt{user\_id}) в payload и подписывается секретным ключом, хранящимся в переменных окружения.
    
    \item \textbf{Авторизация}: Middleware \texttt{JWTAuthMiddleware} проверяет наличие и валидность токена в заголовке \texttt{Authorization} каждого защищенного запроса. При успешной проверке идентификатор пользователя сохраняется в контексте запроса для дальнейшего использования в обработчиках.
\end{enumerate}

Кодовая реализация системы аутентификации представлена в приложении \ref{app:jwt_auth}. Полная реализация слоистой архитектуры backend-приложения, включая примеры обработчиков, сервисов и репозиториев, представлена в приложении \ref{app:backend_implementation}.

\subsubsection{Система уровней и геймификация}

Реализована система прогрессии игрока на основе накопленного опыта (XP) с использованием квадратичной формулы расчета уровня:

$$level = \lfloor \sqrt{\frac{XP}{100}} \rfloor + 1$$

Данная формула обеспечивает экспоненциальный рост требований к опыту для каждого следующего уровня, что создает сбалансированную прогрессию:
\begin{itemize}
    \item Уровень 1: 0-99 XP
    \item Уровень 2: 100-399 XP
    \item Уровень 3: 400-899 XP
    \item Уровень 4: 900-1599 XP
    \item И так далее
\end{itemize}

При выполнении задачи или завершении квеста опыт начисляется пользователю, и уровень автоматически пересчитывается с использованием функции \texttt{calculateLevel}. Обновление уровня происходит атомарно в рамках транзакции вместе с начислением опыта и монет, что гарантирует целостность данных.

Реализация функции \texttt{calculateLevel}:
\begin{minted}{go}
// calculateLevel вычисляет уровень игрока на основе опыта
// Использует квадратичную прогрессию (quadratic progression)
// Формула: level = floor(sqrt(XP / base)) + 1
// Где base = 100 - базовое значение для балансировки прогрессии
func calculateLevel(xp int) int {
    if xp < 0 {
        xp = 0
    }
    
    const baseXP = 100.0
    
    // Квадратичная формула: level = floor(sqrt(XP / base)) + 1
    level := int(math.Floor(math.Sqrt(float64(xp) / baseXP))) + 1
    
    // Минимальный уровень = 1
    if level < 1 {
        level = 1
    }
    
    return level
}
\end{minted}

\subsubsection{Система фильтрации квестов по уровню сложности}

Квесты фильтруются на основе уровня пользователя для обеспечения постепенного открытия контента. Алгоритм фильтрации реализован в методе \texttt{GetAvailableQuests}:

\begin{enumerate}
    \item Получение текущего уровня пользователя и баланса монет из базы данных.
    
    \item Фильтрация квестов по следующим критериям:
    \begin{itemize}
        \item \texttt{difficulty <= user.level + 1} — пользователь может видеть квесты со сложностью не более чем на 1 уровень выше его текущего уровня
        \item \texttt{price <= user.coin\_balance} — пользователь может видеть только те квесты, которые он может себе позволить
        \item Квест не должен быть уже куплен или пройден пользователем
    \end{itemize}
    
    \item Возврат отфильтрованного списка доступных квестов.
\end{enumerate}

Такая система обеспечивает постепенное открытие нового контента по мере прогрессии пользователя, создавая мотивацию для выполнения квестов и повышения уровня.

Реализация метода \texttt{GetAvailableQuests}:
\begin{minted}{go}
func (r *QuestRepository) GetAvailableQuests(
    ctx context.Context, 
    userID int,
) ([]models.Quest, error) {
    // Получаем уровень пользователя и баланс
    var user models.User
    err := r.db.GetContext(ctx, &user, 
        "SELECT * FROM users WHERE id = $1", userID)
    if err != nil {
        return nil, err
    }
    
    // Фильтруем квесты по уровню и балансу
    query := `
        SELECT q.* FROM quests q 
        WHERE q.difficulty <= $1 + 1 
          AND q.price <= $2 
          AND NOT EXISTS (
            SELECT 1 FROM user_quests uq
            WHERE uq.quest_id = q.id AND uq.user_id = $3
          )
    `
    
    var quests []models.Quest
    err = r.db.SelectContext(ctx, &quests, query, 
        user.Level, user.CoinBalance, userID)
    if err != nil {
        return nil, err
    }
    
    return quests, nil
}
\end{minted}

\subsubsection{Управление квестами и задачами с использованием транзакций}

Все критические операции с квестами и задачами выполняются в рамках транзакций PostgreSQL для обеспечения атомарности и целостности данных. Используется метод \texttt{BeginTxx} для создания транзакций с контекстом, что позволяет корректно обрабатывать таймауты и отмену операций.

\textbf{Процесс покупки квеста} реализован следующим образом:
\begin{enumerate}
    \item Начало транзакции: \texttt{tx, err := r.db.BeginTxx(ctx, nil)}
    \item Проверка существования квеста и достаточности средств пользователя
    \item Создание записи в \texttt{user\_quests} со статусом \texttt{'purchased'}
    \item Создание записей в \texttt{user\_tasks} для всех задач квеста со статусом \texttt{'not\_started'}
    \item Списывание монет с баланса пользователя: \texttt{UPDATE users SET coin\_balance = coin\_balance - price}
    \item Создание записи транзакции в \texttt{user\_coin\_transactions} для аудита финансовых операций
    \item Подтверждение транзакции: \texttt{tx.Commit()} или откат при ошибке: \texttt{tx.Rollback()}
\end{enumerate}

\textbf{Процесс выполнения задачи} также выполняется в транзакции:
\begin{enumerate}
    \item Проверка существования квеста в статусе \texttt{'started'} или \texttt{'purchased'}
    \item Проверка существования задачи в статусе \texttt{'active'} или \texttt{'not\_started'}
    \item Если квест в статусе \texttt{'purchased'}, автоматический старт квеста и активация всех задач
    \item Получение базовых наград задачи (\texttt{base\_xp\_reward}, \texttt{base\_coin\_reward})
    \item Начисление наград пользователю с автоматическим пересчетом уровня через функцию \texttt{addXPAndCoinsWithLevelUp}
    \item Обновление статуса задачи на \texttt{'completed'} с сохранением начисленных наград
    \item Подтверждение транзакции
\end{enumerate}

Использование транзакций гарантирует, что все связанные операции выполняются атомарно: либо все изменения применяются, либо ни одно из них не применяется, что критически важно для финансовых операций и системы прогрессии.

Реализация транзакционного начисления наград методом \texttt{addXPAndCoinsWithLevelUp}:
\begin{minted}{go}
func (r *QuestRepository) addXPAndCoinsWithLevelUp(
    tx *sqlx.Tx, 
    ctx context.Context, 
    userID, xpAmount, coinAmount int,
) error {
    // Получаем текущий опыт пользователя
    var currentXP int
    err := tx.GetContext(ctx, &currentXP, 
        "SELECT xp_points FROM users WHERE id = $1", userID)
    if err != nil {
        return err
    }
    
    // Вычисляем новый опыт и уровень
    newXP := currentXP + xpAmount
    newLevel := calculateLevel(newXP)
    
    // Начисляем опыт, монеты и обновляем уровень атомарно
    _, err = tx.ExecContext(ctx, `
        UPDATE users 
        SET xp_points = xp_points + $1,
            coin_balance = coin_balance + $2,
            level = $3
        WHERE id = $4`,
        xpAmount, coinAmount, newLevel, userID)
    if err != nil {
        return err
    }
    
    return nil
}
\end{minted}

Реализация транзакционной обработки покупки квеста методом \texttt{PurchaseQuest} представлена в приложении \ref{app:backend_implementation}. Ниже приведен краткий пример ключевой логики:
\begin{minted}{go}
func (r *QuestRepository) PurchaseQuest(
    ctx context.Context, 
    userID, questID int,
) error {
    tx, err := r.db.BeginTxx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // Получаем информацию о квесте
    var quest models.Quest
    err = tx.GetContext(ctx, &quest, 
        "SELECT * FROM quests WHERE id = $1", questID)
    if err != nil {
        return err
    }
    
    // Проверяем баланс пользователя
    var balance int
    err = tx.GetContext(ctx, &balance, 
        "SELECT coin_balance FROM users WHERE id = $1", userID)
    if err != nil {
        return err
    }
    
    if balance < quest.Price {
        return errors.New("insufficient funds")
    }
    
    // Создаем запись в user_quests
    _, err = tx.ExecContext(ctx, `
        INSERT INTO user_quests (user_id, quest_id, status) 
        VALUES ($1, $2, 'purchased')`,
        userID, questID)
    if err != nil {
        return err
    }
    
    // Создаем user_tasks для всех задач квеста
    _, err = tx.ExecContext(ctx, `
        INSERT INTO user_tasks (user_id, task_id, quest_id, status)
        SELECT $1, qt.task_id, qt.quest_id, 'not_started'
        FROM quest_tasks qt
        WHERE qt.quest_id = $2
        ORDER BY qt.task_order
    `, userID, questID)
    if err != nil {
        return err
    }
    
    // Списываем монеты
    _, err = tx.ExecContext(ctx, `
        UPDATE users SET coin_balance = coin_balance - $1 WHERE id = $2`,
        quest.Price, userID)
    if err != nil {
        return err
    }
    
    // Записываем транзакцию для аудита
    _, err = tx.ExecContext(ctx, `
        INSERT INTO user_coin_transactions 
        (user_id, amount, transaction_type, reference_type, reference_id, description)
        VALUES ($1, $2, 'spent', 'quest', $3, 'Purchased quest: ' || $4)`,
        userID, -quest.Price, quest.ID, quest.Title)
    if err != nil {
        return err
    }
    
    return tx.Commit()
}
\end{minted}

\subsubsection{AI-генерация квестов через LLM API}

Реализована интеграция с LLM API (Intelligence.IO Solutions) для генерации персонализированных квестов на основе текстового запроса пользователя. Используется модель \texttt{moonshotai/Kimi-K2-Thinking}, которая обладает встроенной системой цензуры для предотвращения генерации вредного контента.

\textbf{Процесс генерации квеста:}
\begin{enumerate}
    \item \textbf{Получение запроса}: Пользователь отправляет текстовый промпт с описанием желаемого квеста через endpoint \texttt{POST /quests/generate}.
    
    \item \textbf{Формирование системного промпта}: Создается детальный системный промпт, определяющий структуру JSON-ответа, включающую метаданные квеста (название, описание, категория, редкость, сложность, цена, награды) и массив задач с их параметрами.
    
    \item \textbf{Отправка запроса к LLM}: Выполняется HTTP POST запрос к API \texttt{https://api.intelligence.io.solutions/api/v1/chat/completions} с использованием Bearer токена для аутентификации. Параметры запроса:
    \begin{itemize}
        \item Model: \texttt{moonshotai/Kimi-K2-Thinking}
        \item Temperature: 0.7 (баланс между креативностью и детерминированностью)
        \item Messages: системный промпт и пользовательский запрос
    \end{itemize}
    
    \item \textbf{Обработка ответа}: LLM возвращает JSON-структуру с квестом и задачами. Ответ очищается от thinking-тегов модели (модель использует формат thinking для внутренних рассуждений).
    
    \item \textbf{Парсинг и валидация}: JSON-ответ парсится в структуру \texttt{AIQuestResponse}, содержащую объект \texttt{Quest} и массив \texttt{Tasks}. Выполняется валидация структуры данных.
    
    \item \textbf{Сохранение в базу данных}: Сгенерированный квест и задачи сохраняются в базу данных через метод \texttt{SaveQuestToDB}, который:
    \begin{itemize}
        \item Вставляет запись в таблицу \texttt{quests}
        \item Вставляет записи в таблицу \texttt{tasks}
        \item Создает связи в таблице \texttt{quest\_tasks}
        \item Возвращает идентификатор созданного квеста
    \end{itemize}
    
    \item \textbf{Интеграция с Recommendation Service}: В фоновом режиме (goroutine) отправляется асинхронный запрос к Recommendation Service для добавления нового квеста в индекс поиска и рекомендаций. Это позволяет сразу использовать сгенерированный квест в системе рекомендаций.
    
    \item \textbf{Возврат результата}: Пользователю возвращается полная информация о сгенерированном квесте, включая его идентификатор, метаданные и список задач.
\end{enumerate}

\textbf{Внутренняя цензура KIMI 2}: Модель \texttt{moonshotai/Kimi-K2-Thinking} обладает встроенной системой фильтрации контента, которая автоматически блокирует генерацию квестов с вредным, опасным или неподходящим содержанием. Проведенные тесты показали эффективность данной системы цензуры в предотвращении генерации нежелательного контента.

Реализация интеграции с LLM API методом \texttt{requestAI} (полная версия представлена в приложении \ref{app:ai_quest_generation}):
\begin{minted}{go}
func requestAI(userMessage, systemPrompt, aiModel string) ([]byte, error) {
    if apiKey == "" {
        return nil, fmt.Errorf("API_KEY not found")
    }
    
    if aiModel == "" {
        aiModel = "moonshotai/Kimi-K2-Thinking"
    }
    
    requestData := ChatRequest{
        Model: aiModel,
        Messages: []ChatMessage{
            {Role: "system", Content: systemPrompt},
            {Role: "user", Content: userMessage},
        },
        Temperature: 0.7,
    }
    
    jsonData, err := json.Marshal(requestData)
    if err != nil {
        return nil, fmt.Errorf("error marshaling JSON: %v", err)
    }
    
    req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, fmt.Errorf("error creating request: %v", err)
    }
    
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+apiKey)
    
    client := &http.Client{Timeout: 30 * time.Second}
    resp, err := client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("error reading response: %v", err)
    }
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API returned error: %s", string(body))
    }
    
    var chatResponse ChatResponse
    err = json.Unmarshal(body, &chatResponse)
    if err != nil {
        return nil, fmt.Errorf("error parsing chat response: %v", err)
    }
    
    if len(chatResponse.Choices) == 0 {
        return nil, fmt.Errorf("no choices in response")
    }
    
    // Очищаем ответ от thinking тегов модели
    content := chatResponse.Choices[0].Message.Content
    if idx := strings.Index(content, "</think>\n\n"); idx != -1 {
        content = content[idx+11:] // +11 чтобы пропустить "</think>\n\n"
    }
    
    return []byte(content), nil
}
\end{minted}

\subsubsection{AI-генерация календаря задач}

Реализована функция автоматической генерации расписания задач на основе активных квестов пользователя с использованием LLM API. Алгоритм работает следующим образом:

\begin{enumerate}
    \item \textbf{Сбор контекста}: Система собирает информацию о всех активных квестах пользователя, включая:
    \begin{itemize}
        \item Метаданные квестов (ID, название, описание)
        \item Активные задачи с их текущими параметрами (deadline, duration, scheduled\_start, scheduled\_end, task\_order)
    \end{itemize}
    
    \item \textbf{Формирование промпта}: Создается детальный промпт, включающий:
    \begin{itemize}
        \item Текущую дату и время
        \item Информацию о всех активных квестах и задачах
        \item Пользовательский запрос (например, "Сгенерируй оптимальное расписание")
        \item Правила распределения задач (учет task\_order, равномерное распределение, логическое дополнение существующих данных)
    \end{itemize}
    
    \item \textbf{Генерация расписания}: LLM генерирует JSON-структуру с расписанием для каждой задачи:
    \begin{itemize}
        \item \texttt{scheduled\_start} — время начала выполнения (RFC3339)
        \item \texttt{scheduled\_end} — время окончания выполнения (RFC3339)
        \item \texttt{deadline} — дедлайн задачи (RFC3339 или null)
        \item \texttt{duration} — продолжительность в минутах
    \end{itemize}
    
    \item \textbf{Применение расписания}: Сгенерированное расписание применяется к задачам пользователя и сохраняется в базу данных через метод \texttt{SetOrUpdateScheduleTasks}, который использует \texttt{INSERT ... ON CONFLICT DO UPDATE} для атомарного обновления расписания.
    
    \item \textbf{Интеграция с календарем}: Расписание может быть визуализировано в календарном интерфейсе для удобного планирования и отслеживания задач.
\end{enumerate}

Данная функциональность позволяет пользователям автоматически получать оптимальное расписание выполнения задач с учетом их текущей загрузки, дедлайнов и последовательности выполнения.

\subsubsection{Система дружеских взаимодействий и совместных квестов}

Реализована система социальных взаимодействий, включающая управление дружескими связями и создание совместных квестов.

\textbf{Добавление друзей:}
\begin{enumerate}
    \item Пользователь может добавить друга по username через endpoint \texttt{POST /friends/by-name/:friendName}
    \item Система проверяет существование пользователя с указанным username
    \item Проверяется отсутсвтие в таблице \texttt{friends} дружбы между пользователями.
    \item Создается запись в таблице \texttt{friends} со статусом \texttt{'accepted'} (упрощенная модель без подтверждения)
\end{enumerate}

\textbf{Создание совместных квестов:}
Совместные квесты позволяют двум друзьям проходить квест вместе с синхронным завершением. Процесс реализован в методе \texttt{CreateSharedQuest} и выполняется в рамках транзакции:

\begin{enumerate}
    \item \textbf{Проверка дружбы}: Верификация того, что пользователи являются друзьями (проверка в обоих направлениях связи)
    
    \item \textbf{Создание shared quest}: Создается запись в таблице \texttt{shared\_quests}, связывающая двух пользователей и квест
    
    \item \textbf{Покупка и старт квеста для обоих пользователей}: Для каждого пользователя выполняется:
    \begin{itemize}
        \item Проверка наличия квеста (если не куплен — покупка)
        \item Проверка достаточности средств
        \item Списывание монет
        \item Создание записей в \texttt{user\_quests} и \texttt{user\_tasks}
        \item Автоматический старт квеста (статус меняется на \texttt{'started'})
        \item Активация всех задач (статус меняется на \texttt{'active'})
        \item Установка времени истечения на основе \texttt{time\_limit\_hours}
    \end{itemize}
    
    \item \textbf{Синхронное завершение}: Квест считается завершенным только когда все задачи выполнены обоими пользователями. При завершении квеста одним пользователем система проверяет статус выполнения у второго пользователя.
\end{enumerate}

Все операции выполняются атомарно в рамках одной транзакции, что гарантирует целостность данных и синхронизацию состояния квеста для обоих участников.

\subsubsection{Интеграция с Recommendation Service}\label{subsec:integration_recommendation_service}

Основной backend взаимодействует с Recommendation Service (Python микросервис) через HTTP REST API. Реализованы следующие интеграционные точки:

\textbf{Добавление квестов в индекс:}
При создании нового квеста (включая AI-генерацию) выполняется асинхронный запрос к Recommendation Service для добавления квеста в индекс поиска:
\begin{itemize}
    \item Endpoint: \texttt{POST /api/quests/add}
    \item Данные: ID, название, описание, категория квеста
    \item Выполнение: в отдельной goroutine для неблокирующей обработки
    \item Хранение: данные сохраняются одновременно в SQLite (для персистентности) и в in-memory кэш (для быстрого доступа)
\end{itemize}

\textbf{Добавление пользователей:}
При регистрации или выполнении квестов пользователь может быть добавлен в Recommendation Service для построения семантических профилей:
\begin{itemize}
    \item Endpoint: \texttt{POST /api/users/add}
    \item Данные: user\_id и список ID приобретенных квестов
    \item Позволяет системе строить семантические профили пользователей на основе BERT-эмбеддингов добавленных пользователем квестов
    \item Хранение: данные сохраняются одновременно в SQLite (для персистентности) и в in-memory кэш (для быстрого доступа)
\end{itemize}

\textbf{Синхронизация с PostgreSQL:}
Для обеспечения консистентности данных между основным backend и Recommendation Service реализован механизм синхронизации:
\begin{itemize}
    \item Endpoint: \texttt{POST /api/sync}
    \item Функциональность: получение актуальных данных о квестах и пользователях из PostgreSQL основного backend
    \item Обновление: данные синхронизируются в SQLite Recommendation Service, после чего обновляется in-memory кэш
    \item Использование: позволяет Recommendation Service получать актуальные данные без необходимости постоянной отправки через API endpoints
\end{itemize}

\textbf{Поиск квестов:}
\begin{itemize}
    \item Endpoint: \texttt{POST /api/search}
    \item Параметры: текстовый запрос, категория, статус, top\_K
    \item Возвращает: список квестов с оценками сходства (TF-IDF или BERT)
    \item Backend получает IDs квестов и загружает полные данные из PostgreSQL
\end{itemize}

\textbf{Рекомендация квестов:}
\begin{itemize}
    \item Endpoint: \texttt{POST /api/quests/recommend}
    \item Параметры: список ID квестов пользователя, категория, top\_K
    \item Алгоритм: BERT (семантический анализ приобретенных квестов пользователя)
    \item Возвращает: рекомендации с объяснениями и оценками сходства
\end{itemize}

\textbf{Рекомендация друзей:}
\begin{itemize}
    \item Endpoint: \texttt{POST /api/users/recommend}
    \item Параметры: user\_id, top\_K
    \item Алгоритм: Collaborative Filtering на основе схожести интересов
    \item Backend фильтрует уже существующих друзей из результатов
\end{itemize}

Все запросы к Recommendation Service выполняются с таймаутом 30 секунд для предотвращения зависаний. Ошибки логируются, но не блокируют основную функциональность приложения.

\subsubsection{Обработка голосового ввода (Web Speech API)}

Для удобства пользователей реализована интеграция с Web Speech API браузера, позволяющая преобразовывать голосовой ввод в текст. Данная функциональность реализована на клиентской стороне и используется для голосового ввода промпта для генерации квестов через AI

Web Speech API обеспечивает распознавание речи в реальном времени с поддержкой различных языков и диалектов, что повышает удобство использования системы, особенно на мобильных устройствах.

\subsubsection{Система транзакций и аудит финансовых операций}

Все финансовые операции (покупка квестов, начисление наград) логируются в таблице \texttt{user\_coin\_transactions} для обеспечения полной прозрачности и возможности аудита. Каждая транзакция содержит:
\begin{itemize}
    \item \texttt{user\_id} — идентификатор пользователя
    \item \texttt{amount} — сумма транзакции (положительная для начислений, отрицательная для списаний)
    \item \texttt{transaction\_type} — тип транзакции (\texttt{'earned'} или \texttt{'spent'})
    \item \texttt{reference\_type} — тип связанной сущности (\texttt{'quest'}, \texttt{'task'})
    \item \texttt{reference\_id} — идентификатор связанной сущности
    \item \texttt{description} — текстовое описание транзакции
    \item \texttt{created\_at} — временная метка операции
\end{itemize}

Такая система позволяет отслеживать все финансовые операции пользователя, анализировать паттерны расходования монет и обеспечивать прозрачность игровой экономики.

\subsubsection{Реализация frontend-приложения}

Frontend-приложение разработано на HTML, CSS и JavaScript без использования фреймворков, что обеспечивает минимальные зависимости и быструю загрузку страницы. Приложение представляет собой одностраничное веб-приложение (SPA).

\textbf{Архитектура frontend:}

Приложение организовано в виде модульной структуры с разделением на функциональные блоки:
\begin{itemize}
    \item \textbf{Модуль аутентификации} — обработка регистрации, входа и управления JWT токенами через localStorage
    \item \textbf{Модуль работы с квестами} — отображение доступных квестов, покупка, старт, выполнение задач, завершение квестов
    \item \textbf{Модуль поиска квестов} — интеграция с Recommendation Service для семантического поиска на основе BERT
    \item \textbf{Модуль AI-генерации} — интерфейс для генерации квестов через LLM API с обработкой ответов
    \item \textbf{Модуль друзей} — управление дружескими связями, создание совместных квестов
    \item \textbf{Модуль календаря} — визуализация расписания задач с использованием FullCalendar
    \item \textbf{Модуль карты квестов} — визуализация связей между квестами с использованием Cytoscape.js
\end{itemize}

\textbf{Технологический стек frontend:}

\begin{itemize}
    \item \textbf{HTML5} — семантическая разметка с использованием современных элементов
    \item \textbf{CSS3} — стилизация с использованием CSS Variables для темизации, Flexbox и Grid для адаптивной верстки
    \item \textbf{Vanilla JavaScript (ES6+)} — модульная организация кода с использованием async/await для асинхронных операций
    \item \textbf{Fetch API} — взаимодействие с REST API backend-сервиса
    \item \textbf{FullCalendar} — библиотека для отображения календаря задач
    \item \textbf{Cytoscape.js} — библиотека для визуализации графов связей между квестами
    \item \textbf{Web Speech API} — поддержка голосового ввода для поиска квестов
\end{itemize}

\textbf{Взаимодействие с backend:}

Все взаимодействие с backend осуществляется через единую функцию \texttt{apiCall}, которая:
\begin{itemize}
    \item Автоматически добавляет JWT токен в заголовок \texttt{Authorization}
    \item Обрабатывает ошибки сети и HTTP статусы
    \item Предоставляет единообразный интерфейс для всех API запросов
    \item Реализует обработку таймаутов и повторные попытки при сбоях
\end{itemize}

\textbf{Основные функциональные возможности:}

\begin{enumerate}
    \item \textbf{Система табов} — навигация между разделами приложения (Авторизация, Профиль, Квесты, AI Квесты, Поиск, Друзья, Мои квесты, Календарь, Карта квестов)
    
    \item \textbf{Управление состоянием} — JWT токен хранится в localStorage, состояние приложения управляется через DOM манипуляции
    
    \item \textbf{Динамическое обновление контента} — все данные загружаются асинхронно через Fetch API и отображаются в реальном времени
    
    \item \textbf{Обработка ошибок} — система уведомлений для отображения успешных операций, ошибок и предупреждений
    
    \item \textbf{Адаптивный дизайн} — интерфейс адаптируется под различные размеры экранов с использованием CSS Grid и Flexbox
    
    \item \textbf{Визуализация данных} — календарь задач, граф связей квестов, карточки квестов с метаданными
\end{enumerate}

Frontend интегрирован с Recommendation Service и LLM API через основной backend (детали интеграции описаны в разделе \ref{subsec:integration_recommendation_service}). Пользовательский интерфейс предоставляет возможность семантического поиска квестов и AI-генерации персонализированного контента с отображением результатов в реальном времени. Полная реализация ключевых модулей frontend-приложения представлена в приложении \ref{app:frontend_implementation}.


\subsection{Архитектура базы данных и управление транзакциями}

Спроектирована реляционная база данных на PostgreSQL, отражающая все основные бизнес-сущности системы (см. приложение \ref{app:database_schema}). База данных включает 11 таблиц, организованных в логические группы \cite{db2}. ER-диаграмма базы данных представлена на рис. \ref{fig:database_erd}.
\begin{figure}[H]
    \centering
    \includegraphics[width=1.12\textwidth]{../diagrams/db_diagram.png}
    \caption{ER-диаграмма базы данных системы}
    \label{fig:database_erd}
\end{figure}

\subsubsection{Основные таблицы и их назначение}

\textbf{Пользователи и прогресс:}
\begin{itemize}
    \item \textbf{users} - основная таблица пользователей с учетными данными (username, email, password\_hash), статистикой прогресса (xp\_points, coin\_balance, level)
    \item \textbf{user\_coin\_transactions} - полная история всех операций с внутриигровой валютой для обеспечения прозрачности и аудита финансовых операций
\end{itemize}

\textbf{Задачи и выполнение:}
\begin{itemize}
    \item \textbf{tasks} - каталог всех доступных задач с метаданными (title, description, difficulty, rarity, category) и системой наград (base\_xp\_reward, base\_coin\_reward)
    \item \textbf{user\_tasks} - связь пользователей с задачами, содержащая статус выполнения (not\_started, active, completed), расписание (scheduled\_start, scheduled\_end, deadline, duration), награды за выполнение (xp\_gained, coin\_gained) и флаг подтверждения (is\_confirmed)
    \item \textbf{quest\_tasks} - связующая таблица для композиции квестов из задач с указанием порядка выполнения (task\_order) для поддержки последовательных квестов
\end{itemize}

\textbf{Квестовая система:}
\begin{itemize}
    \item \textbf{quests} - метаданные квестов, включающие структурные параметры (title, description, category, rarity, difficulty, price), условия прохождения (conditions\_json, is\_sequential, time\_limit\_hours), систему наград (reward\_xp, reward\_coin) и опциональные бонусы (bonus\_json)
    \item \textbf{user\_quests} - прогресс пользователей по квестам с отслеживанием статуса (purchased, started, completed), временных меток (started\_at, completed\_at, expires\_at) и полученных наград (xp\_gained, coin\_gained)
\end{itemize}

\textbf{Социальные взаимодействия:}
\begin{itemize}
    \item \textbf{friends} - система дружеских связей с двунаправленными отношениями (проверка в обоих направлениях) и статусом связи (accepted)
    \item \textbf{shared\_quests} - совместные квесты, связывающие двух пользователей (user1\_id, user2\_id) с квестом и отслеживающие статус совместного прохождения
\end{itemize}

\subsubsection{Управление транзакциями и обеспечение целостности данных}

Все критические операции в системе выполняются в рамках транзакций PostgreSQL для обеспечения ACID-свойств (Atomicity, Consistency, Isolation, Durability). Используется библиотека sqlx с методами \texttt{BeginTxx} для создания транзакций с поддержкой контекста. Детальное описание реализации транзакций для конкретных операций (покупка квестов, выполнение задач, создание совместных квестов) представлено в разделе "Управление квестами и задачами с использованием транзакций".

\textbf{Паттерн работы с транзакциями:}
\begin{enumerate}
    \item Создание транзакции: \texttt{tx, err := r.db.BeginTxx(ctx, nil)}
    \item Установка отката при ошибке: \texttt{defer tx.Rollback()}
    \item Выполнение операций в рамках транзакции
    \item Подтверждение: \texttt{return tx.Commit()} или откат при ошибке
\end{enumerate}

Использование транзакций гарантирует, что система всегда находится в консистентном состоянии, даже при возникновении ошибок или сбоев.

\subsubsection{Ключевые бизнес-сущности и их взаимосвязи}

\textbf{Пользователь (users)} является центральной сущностью системы и связан со всеми остальными таблицами через внешние ключи. Содержит информацию об учетных данных, прогрессе по уровням развития (с квадратичной прогрессией) и балансе валюты. Уровень пользователя автоматически пересчитывается при начислении опыта.

\textbf{Задача (tasks)} характеризуется метаданными (название, описание), параметрами сложности (difficulty, rarity, category) и системой наград за выполнение (base\_xp\_reward, base\_coin\_reward). Задачи могут существовать независимо или быть частью квестов.

\textbf{Квест (quests)} включает структурные параметры (название, описание, категория, редкость, сложность, цена), условия прохождения (is\_sequential для последовательных квестов, time\_limit\_hours для ограничения по времени), систему наград (reward\_xp, reward\_coin) и опциональные условия и бонусы в формате JSONB. Квесты могут быть индивидуальными или совместными (через таблицу \texttt{shared\_quests}).

\textbf{Связь квестов и задач} реализована через таблицу \texttt{quest\_tasks}, которая позволяет:
\begin{itemize}
    \item Создавать квесты из произвольного набора задач
    \item Определять порядок выполнения задач (task\_order) для последовательных квестов
    \item Обеспечивать гибкость в композиции квестов
\end{itemize}

\subsection{Процесс выполнения квеста и бизнес-логика}

Для наглядности работы системы разработана диаграмма, иллюстрирующая полный цикл выполнения квеста пользователем (см. рис. \ref{fig:quest_flow}).
\begin{figure}[H]
    \centering
    \includegraphics[width=1.7\textwidth]{../diagrams/quest_flow_diagram.png}
    \caption{Диаграмма процесса выполнения квеста}
    \label{fig:quest_flow}
\end{figure}

\subsubsection{Полный жизненный цикл квеста}

Жизненный цикл квеста включает этапы: просмотр доступных квестов (с фильтрацией по уровню и балансу), покупка квеста (транзакционное списание монет и создание записей в \texttt{user\_quests} и \texttt{user\_tasks}), старт квеста (активация всех задач), выполнение задач (с немедленным начислением наград) и завершение квеста (начисление финальных наград и обновление уровня). Все операции выполняются в рамках транзакций PostgreSQL для обеспечения целостности данных. Детальное описание процесса покупки и выполнения квестов представлено в разделе "Управление квестами и задачами с использованием транзакций".

\subsubsection{Особенности совместных квестов}

Совместные квесты имеют уникальную бизнес-логику:
\begin{itemize}
    \item Квест создается для двух друзей одновременно через \texttt{CreateSharedQuest}
    \item Оба пользователя должны купить квест (списываются средства с каждого)
    \item Квест стартуется для обоих пользователей одновременно
    \item Задачи выполняются независимо каждым пользователем
    \item Квест считается завершенным только когда все задачи выполнены обоими пользователями
    \item При завершении квеста одним пользователем система проверяет статус у второго
    \item Все участники получают полные награды за завершение квеста
\end{itemize}

Такая система обеспечивает синхронизацию прогресса и мотивирует пользователей к совместному прохождению квестов.

\subsection{Реализация Recommendation Service}

Recommendation Service реализован как отдельный микросервис на Python с использованием FastAPI. Сервис отвечает за все операции поиска и рекомендаций, используя различные алгоритмы машинного обучения.

Схема базы данных SQLite Recommendation Service представлена на рис. \ref{fig:sqlite_schema}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../diagrams/sqlite_diagram.png}
    \caption{Схема базы данных SQLite Recommendation Service}
    \label{fig:sqlite_schema}
\end{figure}

\subsubsection{Архитектура Recommendation Service}

Сервис реализован как FastAPI приложение с использованием архитектуры, основанной на состоянии приложения (\texttt{app.state}) для хранения модели и кэша данных. При инициализации сервиса (через \texttt{lifespan}) выполняются следующие операции:

\begin{itemize}
    \item \textbf{Загрузка модели BERT}: Предобученная многоязычная модель \texttt{paraphrase-multilingual-MiniLM-L12-v2} \cite{sentence_transformers} загружается в память и сохраняется в \texttt{app.state.model}. Модель автоматически использует GPU (CUDA), если доступен, иначе CPU.
    
    \item \textbf{Инициализация кэша}: Создаются in-memory структуры данных для хранения эмбеддингов и метаданных:
    \begin{itemize}
        \item \texttt{app.state.quest\_embeddings} — словарь эмбеддингов квестов (ключ: quest\_id, значение: BERT-эмбеддинг)
        \item \texttt{app.state.quests\_data} — метаданные квестов (название, описание, категория)
        \item \texttt{app.state.users\_data} — данные пользователей (список ID квестов пользователя)
        \item \texttt{app.state.profile\_embeddings} — семантические профили пользователей (усредненные эмбеддинги их квестов)
    \end{itemize}
    
    \item \textbf{Загрузка данных из SQLite}: При старте сервиса все данные загружаются из SQLite базы данных \cite{sqlite_docs} в память через \texttt{SQLiteBlobStorage.get\_all\_quests()} и \texttt{SQLiteBlobStorage.get\_all\_users()}, что обеспечивает быстрый доступ к эмбеддингам без обращения к диску при каждом запросе.
    
    \item \textbf{Двухуровневое хранение}: При добавлении новых данных через API эмбеддинги сохраняются одновременно в SQLite (для персистентности) и в in-memory кэш (для быстрого доступа).
\end{itemize}

Полная реализация ключевых компонентов Recommendation Service, включая инициализацию модели, обработку запросов и работу с хранилищем, представлена в приложении \ref{app:recommendation_service_implementation}.

Детальное описание алгоритмов поиска и рекомендаций (BERT, TF-IDF, Collaborative Filtering) представлено в разделе "Реализация алгоритмов рекомендаций и поиска". Основные API endpoints описаны в разделе \ref{subsec:integration_recommendation_service}.

\subsection{Взаимодействие микросервисов и архитектурные решения}

Разрабатываемая система построена на микросервисной архитектуре, разделяющей ответственность между основным backend-сервисом (Go) и Recommendation Service (Python). Такое разделение обеспечивает независимое масштабирование компонентов, возможность использования различных технологий для различных задач и упрощение сопровождения системы. Детальное описание взаимодействия между сервисами представлено в разделе "Взаимодействие между микросервисами" и разделе \ref{subsec:integration_recommendation_service}.

\subsubsection{Обработка ошибок и отказоустойчивость}

Для обеспечения отказоустойчивости системы реализованы следующие механизмы:

\textbf{Таймауты для внешних запросов:}
Все HTTP запросы к внешним сервисам (LLM API, Recommendation Service) выполняются с таймаутом 30 секунд для предотвращения зависаний:
\begin{minted}{go}
client := &http.Client{
    Timeout: 30 * time.Second,
}
\end{minted}

\textbf{Асинхронная обработка некритичных операций:}
Операции, не требующие немедленного ответа клиенту, выполняются асинхронно в goroutines:
\begin{itemize}
    \item Добавление квестов в Recommendation Service после AI-генерации
    \item Обновление индексов поиска
    \item Логирование аналитических данных
\end{itemize}

\textbf{Обработка ошибок внешних сервисов:}
При ошибках взаимодействия с Recommendation Service или LLM API:
\begin{itemize}
    \item Ошибки логируются с использованием structured logging (slog)
    \item Основная функциональность продолжает работать (graceful degradation)
    \item Пользователю возвращается понятное сообщение об ошибке
    \item Система не падает при недоступности внешних сервисов
\end{itemize}

\textbf{Многоуровневая обработка ошибок:}
В системе реализована многоуровневая обработка ошибок:
\begin{itemize}
    \item На уровне репозитория транзакции автоматически откатываются при ошибках
    \item На уровне сервиса бизнес-ошибки преобразуются в понятные сообщения
    \item На уровне обработчика HTTP ошибки возвращаются с соответствующими статус-кодами
    \item Используется structured logging через библиотеку \texttt{slog} для обеспечения читаемости логов
\end{itemize}

\textbf{Health checks:}
Реализованы endpoint'ы для проверки состояния сервисов:
\begin{itemize}
    \item \texttt{GET /tech/ping-db} — проверка доступности PostgreSQL
    \item \texttt{GET /tech/recommendation-service/health} — проверка доступности Recommendation Service
\end{itemize}

\subsubsection{Слоистая архитектура backend-приложения}

Backend-приложение организовано в соответствии с принципами чистой архитектуры и разделено на следующие слои:

\textbf{Handler Layer (handlers/):}
\begin{itemize}
    \item Обработка HTTP запросов и ответов
    \item Валидация входных данных через Gin binding
    \item Извлечение параметров из URL и тела запроса
    \item Вызов методов сервисного слоя
    \item Формирование HTTP ответов
\end{itemize}

\textbf{Service Layer (services/):}
\begin{itemize}
    \item Бизнес-логика приложения
    \item Координация работы репозиториев
    \item Интеграция с внешними сервисами (LLM API, Recommendation Service)
    \item Обработка сложных бизнес-правил
    \item Трансформация данных между слоями
\end{itemize}

\textbf{Repository Layer (repositories/):}
\begin{itemize}
    \item Абстракция доступа к базе данных
    \item Выполнение SQL запросов
    \item Управление транзакциями
    \item Маппинг данных из БД в структуры Go
\end{itemize}

\textbf{Model Layer (models/):}
\begin{itemize}
    \item Определение структур данных
    \item Валидация бизнес-правил
    \item Сериализация/десериализация JSON
\end{itemize}

Такое разделение обеспечивает:
\begin{itemize}
    \item Тестируемость — каждый слой может тестироваться независимо
    \item Поддерживаемость — изменения в одном слое не влияют на другие
    \item Переиспользуемость — бизнес-логика не привязана к HTTP
    \item Масштабируемость — легко добавлять новые endpoint'ы и функциональность
\end{itemize}

Детальная архитектура backend-приложения представлена на рис. \ref{fig:backend_architecture}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{../diagrams/backend_architecture.png}
    \caption{Архитектура backend-приложения (Go)}
    \label{fig:backend_architecture}
\end{figure}

Пример реализации слоистой архитектуры: обработчик запроса вызывает метод сервиса, который использует репозиторий для доступа к базе данных. Полная реализация ключевых компонентов представлена в приложении \ref{app:backend_implementation}.

\subsubsection{Управление конфигурацией и переменными окружения}

Система использует переменные окружения для конфигурации, что обеспечивает:
\begin{itemize}
    \item Безопасность — секретные ключи не хранятся в коде
    \item Гибкость — различные конфигурации для разных окружений (dev, staging, production)
    \item Простоту развертывания — конфигурация через environment variables
\end{itemize}

Основные конфигурационные параметры:
\begin{itemize}
    \item \texttt{JWT\_SECRET} — секретный ключ для подписи JWT токенов
    \item \texttt{API\_KEY\_INTELLIGENCE\_IO} — ключ для доступа к LLM API
    \item \texttt{DATABASE\_URL} — строка подключения к PostgreSQL
    \item \texttt{RECOMMENDATION\_SERVICE\_BASE\_URL} — URL Сервиса Рекоммендаций
\end{itemize}

\subsubsection{Архитектурные паттерны и принципы проектирования}

При разработке системы применялись следующие архитектурные паттерны и принципы:

При разработке применялись следующие архитектурные паттерны: Repository Pattern (абстракция доступа к БД), Service Layer Pattern (централизация бизнес-логики), Dependency Injection (слабое связывание компонентов) и Transaction Script Pattern (атомарные операции в транзакциях). Эти паттерны обеспечивают независимость слоев, тестируемость, поддерживаемость и надежность системы.

\subsubsection{Производительность и оптимизация}\label{subsec:performance_optimization}

Для обеспечения высокой производительности системы применены следующие оптимизации:

\textbf{Оптимизация запросов к базе данных:}
\begin{itemize}
    \item Использование \texttt{SELECT} только необходимых полей вместо \texttt{SELECT *}
    \item Батчинг операций при массовых вставках (например, создание user\_tasks для всех задач квеста)
\end{itemize}

\textbf{Оптимизация Recommendation Service:}
\begin{itemize}
    \item Двухуровневое хранение: SQLite для персистентности и in-memory кэш для быстрого доступа
    \item Кэширование BERT-эмбеддингов в памяти для избежания повторных вычислений
    \item Предвычисление BERT-эмбеддингов при добавлении квестов и сохранение их одновременно в SQLite и кэш
    \item Использование numpy для эффективных векторных операций с эмбеддингами
    \item Оптимизация вычисления косинусного сходства через векторизацию numpy для batch-обработки
    \item Синхронизация с PostgreSQL через HTTP endpoint для обеспечения консистентности данных
\end{itemize}

\textbf{Оптимизация взаимодействия с внешними сервисами:}
\begin{itemize}
    \item Асинхронная обработка некритичных операций (добавление квестов в Recommendation Service) через goroutines
    \item Таймауты для всех внешних HTTP запросов (30 секунд)
\end{itemize}

\textbf{Масштабируемость:}
\begin{itemize}
    \item Микросервисная архитектура позволяет независимо масштабировать Recommendation Service при росте нагрузки
    \item Stateless backend позволяет горизонтально масштабировать основной сервис
\end{itemize}

\subsection{Тестирование и валидация системы}

Для обеспечения качества разработанной системы проведено тестирование ключевых компонентов. Большинство тестов выполнялось вручную, что позволило проверить работу системы в реальных сценариях использования.

\subsubsection{Тестирование алгоритмов рекомендаций}

Сравнительное тестирование эффективности различных алгоритмов (TF-IDF, Collaborative Filtering, BERT) на реальных данных системы подробно описано в разделе <<Реализация алгоритмов рекомендаций и поиска>>. Результаты показали превосходство BERT по всем метрикам качества, что привело к выбору BERT как единственного алгоритма для продакшена. Для автоматизированного тестирования API Recommendation Service использовался скрипт \texttt{test\_api.py} (см. приложение \ref{app:test_api}), который проверяет работу всех endpoints сервиса: семантический поиск, рекомендации квестов и пользователей, поиск похожих квестов.

\subsubsection{Тестирование системы цензуры KIMI 2}

Проведены тесты встроенной системы цензуры модели \texttt{moonshotai/Kimi-K2-Thinking}:
\begin{itemize}
    \item Тестирование на различных типах нежелательного контента
    \item Проверка эффективности фильтрации вредных запросов
    \item Результаты показали высокую эффективность системы цензуры
    \item Модель успешно блокирует генерацию неподходящего контента
\end{itemize}

\subsubsection{Интеграционное и end-to-end тестирование}

Проведено ручное тестирование взаимодействия между компонентами системы:
\begin{itemize}
    \item Тестирование интеграции основного backend с Recommendation Service
    \item Валидация корректности работы транзакций при различных сценариях
    \item End-to-end тестирование пользовательских сценариев: регистрация, создание квестов, выполнение задач, получение рекомендаций
\end{itemize}

\subsection{Направления дальнейшего развития}

Разработанная система предоставляет прочную основу для дальнейшего развития. Возможные направления улучшения:

\begin{itemize}
    \item \textbf{Расширение алгоритмов рекомендаций}: Интеграция более мощных моделей трансформеров (GPT, T5), fine-tuning BERT на данных системы, применение reinforcement learning для адаптации рекомендаций на основе обратной связи пользователей.
    
    \item \textbf{Оптимизация производительности}: Использование векторных баз данных для эффективного поиска похожих эмбеддингов, кэширование результатов рекомендаций, батчинг запросов к Recommendation Service.
    
    \item \textbf{Расширение AI-функциональности}: Реализация fine-tuning моделей на данных системы, добавление генерации изображений для квестов.
    
    \item \textbf{Улучшение системы геймификации}: Добавление системы достижений, реализация лидербордов, внедрение сезонных событий и ограниченных по времени квестов.
    
    \item \textbf{Масштабирование}: Использование message queues (RabbitMQ, Kafka) для асинхронной обработки, внедрение CDN для статического контента, оптимизация запросов к базе данных.
    
    \item \textbf{Мониторинг и аналитика}: Интеграция Prometheus и Grafana для мониторинга метрик, реализация системы аналитики пользовательского поведения, A/B тестирование алгоритмов рекомендаций.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\conclusion
В рамках практики был спроектирован и реализован полнофункциональный адаптивный веб-приложение для саморазвития и постановки целей, включающий frontend-приложение на HTML и JavaScript, основной backend-сервис на Go, Recommendation Service на Python и интегрированную систему AI-генерации контента. Проведенная работа позволила достичь следующих результатов:

\textbf{Анализ и проектирование:}
\begin{enumerate}
    \item Проведен комплексный анализ предметной области и существующих алгоритмов рекомендаций, включая Collaborative Filtering \cite{collaborative_filtering_sarwar, recommender_handbook}, TF-IDF \cite{tfidf_original, tfidf_modern} и современные подходы на основе трансформеров (BERT) \cite{bert_original, bert_semantic_search}. Изучены существующие системы рекомендаций (Amazon \cite{amazon_recommender}, Netflix \cite{netflix_recommender}, Spotify, YouTube) и выявлены их преимущества и ограничения.
    
    \item Выбран и обоснован технологический стек: Go с фреймворком Gin для основного backend-разработки (высокая производительность, конкурентность), Python с FastAPI для Recommendation Service (богатая экосистема ML-библиотек), PostgreSQL в качестве основной системы хранения данных (ACID-транзакции, целостность данных), SQLite \cite{sqlite_docs} для хранения эмбеддингов в Recommendation Service, HTML5 и JavaScript для frontend-разработки.
    
    \item Спроектирована микросервисная архитектура программного комплекса с разделением на основной backend (Go) и Recommendation Service (Python). Разработана ER-диаграмма базы данных PostgreSQL, включающая 11 взаимосвязанных таблиц, а также схема базы данных SQLite для хранения BERT-эмбеддингов и семантических профилей пользователей.
\end{enumerate}

\textbf{Реализация backend-системы:}
\begin{enumerate}
    \setcounter{enumi}{3}
    \item Реализована система аутентификации и авторизации на основе JWT токенов с безопасным хранением паролей через bcrypt, обеспечивающая защиту всех защищенных endpoint'ов через middleware.
    
    \item Реализована слоистая архитектура backend-приложения (Handler → Service → Repository → Model), обеспечивающая тестируемость, поддерживаемость и масштабируемость системы.
    
    \item Реализована система уровней игрока с квадратичной прогрессией (формула: $level = \lfloor \sqrt{XP/100} \rfloor + 1$), обеспечивающая сбалансированную прогрессию и автоматический пересчет уровня при начислении опыта.
    
    \item Реализована система фильтрации квестов по уровню сложности, обеспечивающая постепенное открытие контента по мере прогрессии пользователя (квесты со сложностью не более чем на 1 уровень выше текущего уровня пользователя).
    
    \item Реализована транзакционная обработка всех критических операций (покупка квестов, выполнение задач, создание совместных квестов) с использованием PostgreSQL транзакций \cite{db1, db2}, гарантирующая атомарность и целостность данных.
    
    \item Реализована система аудита финансовых операций через таблицу \texttt{user\_coin\_transactions}, обеспечивающая полную прозрачность всех операций с внутриигровой валютой.
    
    \item Реализована система дружеских взаимодействий с поддержкой добавления друзей по username и создания совместных квестов с синхронным завершением, обеспечивающая социальную мотивацию пользователей.
\end{enumerate}

\textbf{Интеграция AI и машинного обучения:}
\begin{enumerate}
    \setcounter{enumi}{12}
    \item Реализована интеграция с LLM API (Intelligence.IO Solutions, модель KIMI 2) для AI-генерации персонализированных квестов на основе текстовых запросов пользователей. Модель обладает встроенной системой цензуры, эффективно предотвращающей генерацию вредного контента (проведены тесты, подтвердившие эффективность).
    
    \item Реализована AI-генерация календаря задач на основе активных квестов пользователя, позволяющая автоматически создавать оптимальное расписание выполнения задач с учетом дедлайнов, последовательности и текущей загрузки.
    
    \item Проведено сравнительное тестирование алгоритмов рекомендаций квестов и друзей. Для рекомендаций квестов TF-IDF \cite{tfidf_original, tfidf_modern} показал F1@5: 0.370, Collaborative Filtering — F1@5: 0.303, BERT \cite{bert_original, bert_semantic_search, bert_vs_tfidf_cogito, bert_vs_tfidf_iieta} — F1@5: 0.412. Для рекомендаций друзей BERT показал F1@3: 0.641 против 0.636 у TF-IDF и 0.631 у Collaborative Filtering. BERT продемонстрировал лучшие результаты по всем метрикам, что в сочетании с его универсальностью (один алгоритм для поиска квестов, рекомендации квестов и рекомендации друзей) привело к выбору BERT как единственного алгоритма для продакшена.
    
    \item Реализованы алгоритмы поиска и рекомендаций на основе BERT \cite{bert_original, bert_semantic_search} для поиска квестов, рекомендации квестов и рекомендации друзей. Алгоритмы используют предобученную многоязычную модель \texttt{paraphrase-multilingual-MiniLM-L12-v2} из библиотеки sentence-transformers \cite{sentence_transformers} для генерации 384-мерных эмбеддингов и вычисления семантического сходства.
    
    \item Разработан Recommendation Service на Python \cite{python_docs} с использованием FastAPI \cite{fastapi_docs, fastapi_ramirez}, обеспечивающий RESTful API для взаимодействия с основным backend. Сервис реализует двухуровневое хранение данных: SQLite \cite{sqlite_docs} для персистентности эмбеддингов и in-memory кэш для быстрого доступа, что обеспечивает высокую производительность при обработке запросов на рекомендации.
    
    \item Обеспечена интеграция Recommendation Service с основным backend-приложением (Go), включая реализацию клиентских компонентов для взаимодействия с ML-сервисом, обработку ошибок и таймаутов (30 секунд) для обеспечения отказоустойчивости системы. Реализована асинхронная обработка некритичных операций (добавление квестов в Recommendation Service) через goroutines.
\end{enumerate}

\textbf{Реализация frontend-приложения:}
\begin{enumerate}
    \setcounter{enumi}{19}
    \item Разработано frontend-приложение на HTML5 \cite{html2}, CSS3 и JavaScript \cite{js2} без использования фреймворков, представляющее собой одностраничное веб-приложение (SPA) с модульной архитектурой. Приложение интегрировано с основным backend через REST API и обеспечивает полный функционал системы: управление квестами, поиск, AI-генерацию контента, социальные взаимодействия.
    
    \item Реализованы специализированные модули frontend-приложения: модуль аутентификации с управлением JWT токенами, модуль работы с квестами, модуль поиска с интеграцией Recommendation Service, модуль AI-генерации, модуль друзей, модуль календаря задач с использованием FullCalendar и модуль визуализации графов квестов с использованием Cytoscape.js.
    
    \item Реализована обработка голосового ввода через Web Speech API для удобства пользователей, особенно на мобильных устройствах, а также адаптивный дизайн интерфейса с использованием CSS Grid и Flexbox для различных размеров экранов.
\end{enumerate}

\textbf{Тестирование и отказоустойчивость:}
\begin{enumerate}
    \setcounter{enumi}{22}
    \item Проведено тестирование системы, включающее сравнительное тестирование алгоритмов рекомендаций, тестирование системы цензуры LLM модели, интеграционное тестирование взаимодействия между компонентами системы и end-to-end тестирование пользовательских сценариев. Для автоматизированного тестирования Recommendation Service разработан скрипт \texttt{test\_api.py}, проверяющий работу всех endpoints сервиса.
    
    \item Обеспечена отказоустойчивость системы через таймауты для внешних запросов, асинхронную обработку некритичных операций, graceful degradation при недоступности внешних сервисов и многоуровневую обработку ошибок с использованием structured logging.
\end{enumerate}

Реализованная система демонстрирует комплексный подход к созданию адаптивных приложений для саморазвития, объединяющий геймификацию, интеллектуальную персонализацию и автоматическую генерацию контента. Адаптивность системы обеспечивается двумя взаимодополняющими механизмами: системой рекомендаций на основе BERT \cite{bert_original, bert_semantic_search, transformer_attention} для персонализации контента и интеграцией с LLM API для генерации уникальных квестов на основе запросов пользователей.

Сравнительное тестирование алгоритмов рекомендаций (TF-IDF \cite{tfidf_original, tfidf_modern}, Collaborative Filtering \cite{collaborative_filtering_sarwar, recommender_handbook}, BERT) показало превосходство BERT по всем метрикам \cite{bert_vs_tfidf_cogito, bert_vs_tfidf_iieta}, что привело к его выбору как единственного алгоритма для продакшена. Использование транзакций PostgreSQL \cite{db1, db2} обеспечивает надежность и целостность данных во всех критических операциях. Микросервисная архитектура с разделением на основной backend и Recommendation Service обеспечивает независимое масштабирование компонентов системы.

Разработанное решение представляет собой полнофункциональную платформу, готовую к использованию и дальнейшему развитию. Система может быть использована как основа для интеграции более сложных моделей машинного обучения, методов обработки естественного языка \cite{ml_systems_huyen} и расширения функциональности в соответствии с потребностями пользователей. Практическая значимость работы подтверждается реализацией всех ключевых компонентов системы, включая frontend-интерфейс, backend-сервисы, ML-сервис и интеграцию с внешними API.
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Список литературы
\bibliographystyle{gost780uv}
\bibliography{thesis}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\section{Database Schema}\label{app:database_schema}
\begin{lstlisting}[language=SQL]
DROP TABLE IF EXISTS user_achievements CASCADE;
DROP TABLE IF EXISTS achievements CASCADE;
DROP TABLE IF EXISTS user_coin_transactions CASCADE;
DROP TABLE IF EXISTS user_daily_streaks CASCADE;
DROP TABLE IF EXISTS user_completed_tasks CASCADE;
DROP TABLE IF EXISTS task_variants CASCADE;
DROP TABLE IF EXISTS tasks CASCADE;
DROP TABLE IF EXISTS user_completed_quests CASCADE;
DROP TABLE IF EXISTS user_current_quests CASCADE;
DROP TABLE IF EXISTS user_quests CASCADE;
DROP TABLE IF EXISTS quest_tasks CASCADE;
DROP TABLE IF EXISTS quests CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS categories CASCADE;

DROP TYPE IF EXISTS category_name CASCADE;
DROP TYPE IF EXISTS difficulty_level CASCADE;
DROP TYPE IF EXISTS task_type CASCADE;
DROP TYPE IF EXISTS rarity CASCADE;

CREATE TYPE category_name AS ENUM ('health', 'intelligence', 'charisma', 'willpower');
CREATE TYPE rarity AS ENUM ('free', 'common', 'rare', 'epic', 'legendary');
CREATE TYPE task_type AS ENUM ('daily', 'weekly', 'special', 'user_generated');

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(100) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    xp_points INT DEFAULT 0,
    coin_balance INT DEFAULT 0,
    level INT DEFAULT 0,
    health_level INT DEFAULT 0,
    mental_health_level INT DEFAULT 0,
    intelligence_level INT DEFAULT 0,
    charisma_level INT DEFAULT 0,
    willpower_level INT DEFAULT 0,
    current_streak INT DEFAULT 0,
    longest_streak INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_active_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    difficulty INT DEFAULT 0,
    rarity VARCHAR(255) NOT NULL DEFAULT 'free',
    category VARCHAR(255) NOT NULL,
    base_xp_reward INT NOT NULL DEFAULT 0,
    base_coin_reward INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_completed_tasks (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    task_id INT NOT NULL,
    is_confirmed BOOL DEFAULT FALSE NOT NULL,
    completed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    xp_gained INT NOT NULL,
    coin_gained INT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE TABLE user_coin_transactions (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    reference_type VARCHAR(50) NOT NULL,
    reference_id INT,
    transaction_type VARCHAR(50) NOT NULL,
    amount INT NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE achievements (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    criteria_json JSONB NOT NULL,
    bonus_json JSONB,
    reward_xp INT DEFAULT 0,
    reward_coin INT DEFAULT 0,
    is_secret BOOLEAN DEFAULT FALSE
);

CREATE TABLE user_achievements (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    achievement_id INT NOT NULL,
    unlocked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (achievement_id) REFERENCES achievements(id) ON DELETE CASCADE,
    CONSTRAINT unique_user_achievement UNIQUE (user_id, achievement_id)
);

CREATE TABLE quests (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(255) NOT NULL,
    rarity VARCHAR(255) NOT NULL,
    difficulty INT NOT NULL DEFAULT 0,
    price INT NOT NULL DEFAULT 0,
    tasks_count INT DEFAULT 1,
    conditions_json JSONB,
    bonus_json JSONB,
    is_sequential BOOLEAN DEFAULT FALSE,
    reward_xp INT NOT NULL,
    reward_coin INT NOT NULL,
    time_limit_hours INT DEFAULT 0
);

CREATE TABLE quest_tasks (
    id SERIAL PRIMARY KEY,
    quest_id INT NOT NULL,
    task_id INT NOT NULL,
    task_order INT,
    FOREIGN KEY (quest_id) REFERENCES quests(id) ON DELETE CASCADE,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE TABLE user_quests (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    quest_id INT NOT NULL,
    status VARCHAR(255) NOT NULL DEFAULT 'purchased',
    tasks_done INT DEFAULT 0,
    xp_gained INT,
    coin_gained INT,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    expires_at TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (quest_id) REFERENCES quests(id) ON DELETE CASCADE
);

CREATE TABLE friends (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    friend_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(50) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, friend_id)
);

CREATE TABLE shared_quests (
    id SERIAL PRIMARY KEY,
    quest_id INTEGER NOT NULL REFERENCES quests(id) ON DELETE CASCADE,
    user1_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    user2_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status VARCHAR(50) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
\end{lstlisting}

\section{JWT Authentication Implementation}\label{app:jwt_auth}

Middleware для валидации JWT-токена validation и управления контекстом пользователя.
\begin{minted}{go}
package middleware

import (
    "BecomeOverMan/internal/services"
    "errors"
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
)

func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Missing or invalid token"})
            return
        }

        tokenStr := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := services.ValidateJWT(tokenStr)
        if err != nil {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
            return
        }

        c.Set("user_id", claims.UserID)
        c.Next()
    }
}

func GetUserID(c *gin.Context) (int, error) {
    userIDKey, exists := c.Get("user_id")
    if !exists {
        return 0, errors.New("Cannot get user_id from context")
    }

    userID, ok := userIDKey.(int)
    if !ok {
        return 0, errors.New("User ID is not integer")
    }

    return userID, nil
}
\end{minted}

JWT service для генерации и валидации токена.
\begin{minted}{go}
package services

import (
    "os"
    "time"

    "github.com/golang-jwt/jwt/v5"
)

var jwtKey = []byte(os.Getenv("JWT_SECRET"))

type Claims struct {
    UserID int `json:"user_id"`
    jwt.RegisteredClaims
}

func GenerateJWT(userID int) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour)
    claims := &Claims{
        UserID: userID,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(expirationTime),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtKey)
}

func ValidateJWT(tokenStr string) (*Claims, error) {
    claims := &Claims{}
    token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
        return jwtKey, nil
    })

    if err != nil || !token.Valid {
        return nil, err
    }

    return claims, nil
}
\end{minted}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{AI Quest Generation Implementation}\label{app:ai_quest_generation}

Реализация генерации квестов через LLM API с обработкой ответа и сохранением в базу данных.

\begin{minted}{go}
func (h *QuestHandler) GenerateAIQuest(c *gin.Context) {
    var request RequestAI
    if err := c.ShouldBindJSON(&request); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
        return
    }
    
    // Генерация квеста через LLM API
    aiResponse, err := h.questService.GenerateAIQuest(request.Prompt)
    if err != nil {
        c.JSON(http.StatusInternalServerError, 
            gin.H{"error": "Failed to generate quest: " + err.Error()})
        return
    }
    
    // Сохранение квеста в БД
    questID, err := h.questService.SaveQuestToDB(aiResponse.Quest, aiResponse.Tasks)
    if err != nil {
        c.JSON(http.StatusInternalServerError, 
            gin.H{"error": "Failed to save quest: " + err.Error()})
        return
    }
    
    // Асинхронная отправка в Recommendation Service
    req := models.RecommendationService_AddQuests_Request{
        Quests: []models.RecommendationService_questToAdd{
            {
                ID:          questID,
                Title:       aiResponse.Quest.Title,
                Description: aiResponse.Quest.Description,
                Category:    aiResponse.Quest.Category,
            },
        },
    }
    
    go func() {
        err := h.sendQuestToRecommendationService(req)
        if err != nil {
            slog.Error("Failed to send quest to recommendation service", "error", err)
        }
    }()
    
    c.JSON(http.StatusOK, gin.H{
        "message":  "Quest generated successfully",
        "quest_id": questID,
        "quest":    aiResponse.Quest,
        "tasks":    aiResponse.Tasks,
    })
}
\end{minted}

\section{Friends Quests Implementation}\label{app:friends_quests}

Методы слоя <<Репозиторий>> для добавления в друзья и создания дружеских квестов.

\begin{minted}{go}
package repositories

import (
    "BecomeOverMan/internal/models"
    "errors"

    "github.com/jmoiron/sqlx"
)

func (r *UserRepository) AddFriend(userID, friendID int) error {
    var userExists bool
    err := r.db.Get(&userExists, `
        SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)`, friendID)
    if err != nil {
        return err
    }
    if !userExists {
        return errors.New("user not found")
    }

    var friendshipExists bool
    err = r.db.Get(&friendshipExists, `
        SELECT EXISTS(SELECT 1 FROM friends WHERE user_id = $1 AND friend_id = $2)`,
        userID, friendID)
    if err != nil {
        return err
    }
    if friendshipExists {
        return errors.New("friendship already exists")
    }

    _, err = r.db.Exec(`
        INSERT INTO friends (user_id, friend_id, status) 
        VALUES ($1, $2, 'accepted')`,
        userID, friendID)
    return err
}

func (r *UserRepository) GetFriends(userID int) ([]models.Friend, error) {
    var friends []models.Friend
    query := `
        SELECT f.*, u.username 
        FROM friends f 
        JOIN users u ON f.friend_id = u.id 
        WHERE f.user_id = $1 AND f.status = 'accepted'
    `
    err := r.db.Select(&friends, query, userID)
    return friends, err
}
\end{minted}

Метод CreateSharedQuest использует SQL-транзакции для безопасной и надежной работы с БД.

\begin{minted}{go}
func (r *QuestRepository) CreateSharedQuest(user1ID, user2ID, questID int) error {
    tx, err := r.db.Beginx()
    if err != nil {
        return err
    }
    defer tx.Rollback()

    var areFriends bool
    err = tx.Get(&areFriends, `
        SELECT EXISTS(
            SELECT 1 FROM friends 
            WHERE user_id = $1 AND friend_id = $2 AND status = 'accepted'
        )`, user1ID, user2ID)
    if err != nil {
        return err
    }
    if !areFriends {
        return errors.New("users are not friends")
    }

    _, err = tx.Exec(`
        INSERT INTO shared_quests (user1_id, user2_id, quest_id, status) 
        VALUES ($1, $2, $3, 'active')`,
        user1ID, user2ID, questID)
    if err != nil {
        return err
    }

    if err := r.startQuestForUser(tx, user1ID, questID); err != nil {
        return err
    }
    if err := r.startQuestForUser(tx, user2ID, questID); err != nil {
        return err
    }

    return tx.Commit()
}

func (r *QuestRepository) startQuestForUser(tx *sqlx.Tx, userID, questID int) error {
    var alreadyPurchased bool
    err := tx.Get(&alreadyPurchased, `
        SELECT EXISTS(SELECT 1 FROM user_quests WHERE user_id = $1 AND quest_id = $2)`,
        userID, questID)
    if err != nil {
        return err
    }

    if !alreadyPurchased {
        var price int
        err := tx.Get(&price, "SELECT price FROM quests WHERE id = $1", questID)
        if err != nil {
            return err
        }

        var balance int
        err = tx.Get(&balance, "SELECT coin_balance FROM users WHERE id = $1", userID)
        if err != nil {
            return err
        }

        if balance < price {
            return errors.New("not enough coins for shared quest")
        }

        _, err = tx.Exec(`
            INSERT INTO user_quests (user_id, quest_id, status, tasks_done) 
            VALUES ($1, $2, 'purchased', 0)`,
            userID, questID)
        if err != nil {
            return err
        }

        _, err = tx.Exec(`
            UPDATE users SET coin_balance = coin_balance - $1 WHERE id = $2`,
            price, userID)
        if err != nil {
            return err
        }
    }

    _, err = tx.Exec(`
        UPDATE user_quests 
        SET status = 'started', started_at = NOW() 
        WHERE user_id = $1 AND quest_id = $2`,
        userID, questID)

    return err
}
\end{minted}

\section{Backend Implementation (Go)}\label{app:backend_implementation}

Реализация ключевых компонентов backend-приложения на Go, демонстрирующая слоистую архитектуру и использование транзакций PostgreSQL.

\subsection{Инициализация приложения}

Точка входа приложения, демонстрирующая инициализацию базы данных, создание репозиториев, сервисов и регистрацию маршрутов:

\begin{minted}{go}
package main

import (
    "BecomeOverMan/internal/config"
    "BecomeOverMan/internal/handlers"
    "log"
    "log/slog"
    "BecomeOverMan/internal/repositories"
    "BecomeOverMan/internal/services"
    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/jmoiron/sqlx"
    _ "github.com/lib/pq"
)

func main() {
    slog.SetLogLoggerLevel(slog.LevelDebug)

    // Подключение к базе данных
    db, err := sqlx.Connect("postgres", config.Cfg.DatabaseURL)
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    defer db.Close()

    // Создание репозиториев
    techRepo := repositories.NewTechRepository(db)
    userRepo := repositories.NewUserRepository(db)
    questRepo := repositories.NewQuestRepository(db)

    // Создание сервисов
    techService := services.NewTechService(techRepo)
    userService := services.NewUserService(userRepo)
    questService := services.NewQuestService(questRepo, userRepo)

    // Инициализация роутера
    r := gin.Default()
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
        AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
        AllowCredentials: true,
    }))

    // Регистрация маршрутов
    handlers.RegisterTechRoutes(r, techService)
    handlers.RegisterUserRoutes(r, userService)
    handlers.RegisterQuestRoutes(r, questService)

    if err := r.Run("0.0.0.0:8080"); err != nil {
        log.Fatal("Failed to start server:", err)
    }
}
\end{minted}

\subsection{Handler Layer}

Пример обработчика запросов, демонстрирующий валидацию входных данных и вызов сервисного слоя:

\begin{minted}{go}
func (h *QuestHandler) PurchaseQuestHandler(c *gin.Context) {
    questIDStr := c.Param("questID")
    questID, err := strconv.Atoi(questIDStr)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quest ID"})
        return
    }

    userID, err := middleware.GetUserID(c)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    err = h.questService.PurchaseQuest(c.Request.Context(), userID, questID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "Quest purchased successfully"})
}
\end{minted}

\subsection{Service Layer}

Пример сервисного слоя, демонстрирующий бизнес-логику и интеграцию с внешними сервисами:

\begin{minted}{go}
func (s *QuestService) PurchaseQuest(ctx context.Context, userID, questID int) error {
    // Вызов репозитория для покупки квеста
    err := s.questRepo.PurchaseQuest(ctx, userID, questID)
    if err != nil {
        slog.Error("Failed to purchase quest", "error", err)
        return err
    }

    // Асинхронная отправка данных в Recommendation Service
    go func() {
        questIDs, err := s.getUserQuestIDs(userID)
        if err != nil {
            slog.Error("Failed to get user quest IDs", "error", err)
            return
        }

        req := models.RecommendationService_AddUsers_Request{
            Users: []models.UserWithQuestIDS{
                {UserID: userID, QuestIDs: questIDs},
            },
        }

        _, err = s.sendUserQuestToRecommendationService(req)
        if err != nil {
            slog.Error("Failed to send user quest to recommendation service", "error", err)
        }
    }()

    return nil
}
\end{minted}

\subsection{Repository Layer с транзакциями}

Полная реализация метода покупки квеста с использованием транзакций PostgreSQL:

\begin{minted}{go}
func (r *QuestRepository) PurchaseQuest(
    ctx context.Context, 
    userID, questID int,
) error {
    tx, err := r.db.BeginTxx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // Получаем информацию о квесте
    var quest models.Quest
    err = tx.GetContext(ctx, &quest, 
        "SELECT * FROM quests WHERE id = $1", questID)
    if err != nil {
        return err
    }

    // Проверяем баланс пользователя
    var balance int
    err = tx.GetContext(ctx, &balance, 
        "SELECT coin_balance FROM users WHERE id = $1", userID)
    if err != nil {
        return err
    }

    if balance < quest.Price {
        return errors.New("insufficient funds")
    }

    // Создаем запись в user_quests
    _, err = tx.ExecContext(ctx, `
        INSERT INTO user_quests (user_id, quest_id, status) 
        VALUES ($1, $2, 'purchased')`,
        userID, questID)
    if err != nil {
        return err
    }

    // Создаем user_tasks для всех задач квеста
    _, err = tx.ExecContext(ctx, `
        INSERT INTO user_tasks (user_id, task_id, quest_id, status)
        SELECT $1, qt.task_id, qt.quest_id, 'not_started'
        FROM quest_tasks qt
        WHERE qt.quest_id = $2
        ORDER BY qt.task_order
    `, userID, questID)
    if err != nil {
        return err
    }

    // Списываем монеты
    _, err = tx.ExecContext(ctx, `
        UPDATE users SET coin_balance = coin_balance - $1 WHERE id = $2`,
        quest.Price, userID)
    if err != nil {
        return err
    }

    // Записываем транзакцию для аудита
    _, err = tx.ExecContext(ctx, `
        INSERT INTO user_coin_transactions 
        (user_id, amount, transaction_type, reference_type, reference_id, description)
        VALUES ($1, $2, 'spent', 'quest', $3, 'Purchased quest: ' || $4)`,
        userID, -quest.Price, quest.ID, quest.Title)
    if err != nil {
        return err
    }

    return tx.Commit()
}
\end{minted}

\section{Recommendation Service Implementation (Python)}\label{app:recommendation_service_implementation}

Реализация ключевых компонентов Recommendation Service на Python FastAPI, демонстрирующая работу с BERT-моделью, кэшированием и двухуровневым хранением данных.

\subsection{Инициализация приложения и загрузка модели}

Инициализация FastAPI приложения с загрузкой BERT-модели и данных из SQLite:

\begin{minted}{python}
from fastapi import FastAPI
from sentence_transformers import SentenceTransformer
from contextlib import asynccontextmanager
from internal.repo.db import SQLiteBlobStorage
import torch

storage = SQLiteBlobStorage()
NLP_MODEL = "paraphrase-multilingual-MiniLM-L12-v2"

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Загрузка модели BERT
    logger.info("Загружаем модель BERT...")
    app.state.model = SentenceTransformer(NLP_MODEL)
    app.state.device = 'cuda' if torch.cuda.is_available() else 'cpu'
    app.state.model.to(app.state.device)
    logger.info(f"Модель загружена на {app.state.device}")

    # Инициализация in-memory кэша
    app.state.quest_embeddings = {}
    app.state.quests_data = {}
    app.state.users_data = {}
    app.state.profile_embeddings = {}

    # Загрузка данных из SQLite в память
    logger.info("Загружаем данные из базы данных...")
    app.state.quests_data, app.state.quest_embeddings = storage.get_all_quests()
    app.state.users_data, app.state.profile_embeddings = storage.get_all_users()
    logger.info(f"Загружено квестов: {len(app.state.quests_data)}")
    logger.info(f"Загружено пользователей: {len(app.state.users_data)}")

    yield

    # Закрываем БД при выключении
    logger.info("Выключаем API...")
    storage.close()

app = FastAPI(title="Recommendation BERT API", lifespan=lifespan)
\end{minted}

\subsection{Семантический поиск квестов}

Реализация endpoint'а для семантического поиска квестов на основе BERT:

\begin{minted}{python}
@app.post("/api/search")
async def search_quests(request: SearchRequest):
    """Семантический поиск квестов на основе BERT"""
    start_time = time.time()
    
    # Генерация эмбеддинга запроса
    query_embedding = app.state.model.encode(
        request.query,
        convert_to_numpy=True,
        show_progress_bar=False
    )
    
    # Вычисление косинусного сходства со всеми квестами
    similarities = []
    for quest_id, quest_embedding in app.state.quest_embeddings.items():
        similarity = util.cos_sim(query_embedding, quest_embedding).item()
        
        # Фильтрация по категории, если указана
        if request.category:
            quest_data = app.state.quests_data.get(quest_id)
            if quest_data and quest_data.get('category') != request.category:
                continue
        
        similarities.append({
            'quest_id': quest_id,
            'similarity': similarity,
            'quest_data': app.state.quests_data.get(quest_id)
        })
    
    # Сортировка по убыванию сходства
    similarities.sort(key=lambda x: x['similarity'], reverse=True)
    
    # Возврат top-K результатов
    results = similarities[:request.top_k]
    
    search_time_ms = (time.time() - start_time) * 1000
    
    return {
        'results': [
            {
                'id': r['quest_id'],
                'title': r['quest_data']['title'],
                'description': r['quest_data']['description'],
                'category': r['quest_data'].get('category'),
                'similarity_score': round(r['similarity'], 4)
            }
            for r in results
        ],
        'search_time_ms': round(search_time_ms, 2)
    }
\end{minted}

\subsection{Рекомендация квестов на основе профиля пользователя}

Реализация алгоритма рекомендации квестов с использованием семантического профиля пользователя:

\begin{minted}{python}
@app.post("/api/quests/recommend")
async def recommend_quests(request: RecommendQuestsRequest):
    """Рекомендация квестов на основе семантического профиля пользователя"""
    
    user_quest_ids = request.user_quest_ids
    
    if not user_quest_ids:
        # Для новых пользователей возвращаем популярные квесты
        all_quests = list(app.state.quests_data.values())
        return {
            'recommendations': all_quests[:request.top_k],
            'message': 'Новый пользователь: показаны популярные квесты'
        }
    
    # Получение или вычисление семантического профиля пользователя
    if request.user_id in app.state.profile_embeddings:
        user_profile = app.state.profile_embeddings[request.user_id]
    else:
        # Вычисление профиля как среднего эмбеддинга квестов пользователя
        quest_embeddings = [
            app.state.quest_embeddings[qid] 
            for qid in user_quest_ids 
            if qid in app.state.quest_embeddings
        ]
        if not quest_embeddings:
            return {'recommendations': [], 'message': 'Не найдено квестов для профиля'}
        
        user_profile = np.mean(quest_embeddings, axis=0)
        app.state.profile_embeddings[request.user_id] = user_profile
    
    # Вычисление сходства со всеми квестами
    recommendations = []
    for quest_id, quest_embedding in app.state.quest_embeddings.items():
        # Пропускаем квесты, которые уже есть у пользователя
        if quest_id in user_quest_ids:
            continue
        
        # Фильтрация по категории, если указана
        if request.category:
            quest_data = app.state.quests_data.get(quest_id)
            if quest_data and quest_data.get('category') != request.category:
                continue
        
        similarity = util.cos_sim(user_profile, quest_embedding).item()
        recommendations.append({
            'quest_id': quest_id,
            'similarity': similarity,
            'quest_data': app.state.quests_data.get(quest_id)
        })
    
    # Сортировка и возврат top-K
    recommendations.sort(key=lambda x: x['similarity'], reverse=True)
    top_recommendations = recommendations[:request.top_k]
    
    return {
        'recommendations': [
            {
                'id': r['quest_id'],
                'title': r['quest_data']['title'],
                'description': r['quest_data']['description'],
                'category': r['quest_data'].get('category'),
                'similarity_score': round(r['similarity'], 4),
                'explanation': _get_recommendation_explanation(
                    r['quest_data'], r['similarity']
                )
            }
            for r in top_recommendations
        ]
    }
\end{minted}

\section{Frontend Implementation (JavaScript)}\label{app:frontend_implementation}

Реализация ключевых компонентов frontend-приложения на JavaScript, демонстрирующая модульную архитектуру и взаимодействие с backend API.

\subsection{Модуль работы с API}

Единая функция для всех API запросов с обработкой JWT токенов и ошибок:

\begin{minted}{javascript}
// api.js - Модуль для работы с API
const API_BASE_URL = 'http://localhost:8080';

async function apiCall(endpoint, options = {}) {
    const token = localStorage.getItem('token');
    
    const config = {
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...(token && { 'Authorization': `Bearer ${token}` }),
            ...options.headers
        }
    };

    try {
        const response = await fetch(`${API_BASE_URL}${endpoint}`, config);
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Request failed');
        }
        
        return await response.json();
    } catch (error) {
        console.error('API call error:', error);
        throw error;
    }
}

// Примеры использования
async function getAvailableQuests() {
    return apiCall('/quests/available', { method: 'GET' });
}

async function purchaseQuest(questID) {
    return apiCall(`/quests/${questID}/purchase`, { method: 'POST' });
}

async function searchQuests(query, category = null) {
    return apiCall('/quests/search', {
        method: 'POST',
        body: JSON.stringify({ query, category, top_k: 5 })
    });
}
\end{minted}

\subsection{Модуль управления квестами}

Обработка отображения и управления квестами:

\begin{minted}{javascript}
// quests.js - Модуль управления квестами
class QuestManager {
    constructor() {
        this.quests = [];
    }

    async loadAvailableQuests() {
        try {
            this.quests = await getAvailableQuests();
            this.renderQuests();
        } catch (error) {
            showNotification('Ошибка загрузки квестов', 'error');
        }
    }

    renderQuests() {
        const container = document.getElementById('quests-container');
        container.innerHTML = this.quests.map(quest => `
            <div class="quest-card">
                <h3>${quest.title}</h3>
                <p>${quest.description}</p>
                <div class="quest-meta">
                    <span>Категория: ${quest.category}</span>
                    <span>Цена: ${quest.price} монет</span>
                    <span>Сложность: ${quest.difficulty}</span>
                </div>
                <button onclick="questManager.purchaseQuest(${quest.id})">
                    Купить квест
                </button>
            </div>
        `).join('');
    }

    async purchaseQuest(questID) {
        try {
            await purchaseQuest(questID);
            showNotification('Квест успешно куплен!', 'success');
            await this.loadAvailableQuests();
        } catch (error) {
            showNotification(error.message, 'error');
        }
    }
}

const questManager = new QuestManager();
\end{minted}

\subsection{Модуль семантического поиска}

Интеграция с Recommendation Service для семантического поиска:

\begin{minted}{javascript}
// search.js - Модуль семантического поиска
class SearchManager {
    constructor() {
        this.setupSearchForm();
    }

    setupSearchForm() {
        const form = document.getElementById('search-form');
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const query = document.getElementById('search-query').value;
            const category = document.getElementById('search-category').value || null;
            await this.performSearch(query, category);
        });
    }

    async performSearch(query, category) {
        try {
            const results = await searchQuests(query, category);
            this.displayResults(results);
        } catch (error) {
            showNotification('Ошибка поиска', 'error');
        }
    }

    displayResults(results) {
        const container = document.getElementById('search-results');
        container.innerHTML = results.map(result => `
            <div class="search-result">
                <h4>${result.title}</h4>
                <p>${result.description}</p>
                <div class="similarity-score">
                    Схожесть: ${(result.similarity_score * 100).toFixed(1)}%
                </div>
            </div>
        `).join('');
    }
}

const searchManager = new SearchManager();
\end{minted}

\section{Recommendation Service API Testing Script}\label{app:test_api}

Скрипт для автоматизированного тестирования всех endpoints Recommendation Service. Проверяет работу семантического поиска, рекомендаций квестов и пользователей, поиска похожих квестов, а также комплексные пользовательские сценарии.

\begin{minted}{python}
# test_bert_api.py
import requests
import json
import time
import random

# Базовый URL API
BASE_URL = "http://localhost:8000"

# Расширенные квесты с более подробными описаниями
quests_data = [
    {
        "id": 1,
        "title": "Утренний дружеский марафон",
        "description": "Совместный недельный челлендж для развития силы воли и здоровья. Ежедневные утренние пробежки, здоровое питание и медитация.",
        "category": "health"
    },
    # ... остальные квесты
]

# Тестовые пользователи с разными интересами
users_data = [
    {
        "user_id": 101,
        "quest_ids": [1, 4, 6]  # Фитнес-энтузиаст
    },
    # ... остальные пользователи
]

def test_api():
    print("Расширенное тестирование BERT API\n")
    
    # 1. Проверяем доступность API
    try:
        health_response = requests.get(f"{BASE_URL}/api/health")
        if health_response.status_code == 200:
            print(f"API работает: {health_response.json()}")
    except:
        print("Не могу подключиться к API")
        return
    
    # 2. Добавляем квесты
    add_response = requests.post(
        f"{BASE_URL}/api/quests/add",
        json={"quests": quests_data}
    )
    if add_response.status_code == 200:
        result = add_response.json()
        print(f"Добавлено квестов: {result.get('added', len(quests_data))}")
    
    # 3. Добавляем пользователей
    add_users_response = requests.post(
        f"{BASE_URL}/api/users/add",
        json={"users": users_data}
    )
    if add_users_response.status_code == 200:
        result = add_users_response.json()
        print(f"Добавлено пользователей: {result.get('total_users', len(users_data))}")
    
    # 4. Тестируем семантический поиск
    test_queries = [
        ("бег и физические упражнения", None),
        ("утренние привычки и медитация", "willpower"),
        ("гитара музыка творчество", "creativity"),
    ]
    
    for query, category in test_queries:
        search_data = {
            "query": query,
            "top_k": 3,
            "category": category
        }
        search_response = requests.post(
            f"{BASE_URL}/api/search",
            json=search_data,
            timeout=10
        )
        if search_response.status_code == 200:
            results = search_response.json()
            print(f"🔍 Запрос: '{query}' - найдено результатов: {len(results.get('results', []))}")
    
    # 5. Тестируем рекомендации квестов
    recommendation_tests = [
        (101, "Фитнес-энтузиаст", None),
        (102, "Творческая личность", "creativity"),
        (108, "Новый пользователь (без истории)", None)
    ]
    
    for user_id, user_type, category in recommendation_tests:
        user_quest_ids = []
        for user in users_data:
            if user["user_id"] == user_id:
                user_quest_ids = user["quest_ids"]
                break
        
        recommend_data = {
            "user_quest_ids": user_quest_ids,
            "top_k": 5,
            "category": category
        }
        recommend_response = requests.post(
            f"{BASE_URL}/api/quests/recommend",
            json=recommend_data,
            timeout=10
        )
        if recommend_response.status_code == 200:
            results = recommend_response.json()
            print(f"Рекомендации для {user_type}: {len(results.get('recommendations', []))}")
    
    # 6. Тестируем рекомендации пользователей
    for user_id in [101, 102, 103]:
        recommend_users_data = {
            "user_id": user_id,
            "top_k": 3
        }
        recommend_response = requests.post(
            f"{BASE_URL}/api/users/recommend",
            json=recommend_users_data,
            timeout=10
        )
        if recommend_response.status_code == 200:
            results = recommend_response.json()
            print(f"Рекомендации пользователей для ID {user_id}: {len(results.get('results', []))}")
    
    print("\nТестирование завершено!")

if __name__ == "__main__":
    test_api()
\end{minted}

Полный код скрипта (578 строк) доступен в файле \texttt{RecommendationService/src/recommendation\_bert\_api/test\_api.py}. Скрипт включает тестирование всех endpoints Recommendation Service: добавление квестов и пользователей, семантический поиск, поиск похожих квестов, рекомендации квестов и пользователей, а также комплексные пользовательские сценарии и тесты производительности.

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
